[{"title":"APK瘦身-是时候给App进行减负了","url":"/2019/02/19/APK瘦身-是时候给App进行减负了/","content":"\n### 前言 ###\n\nAPK瘦身即是对APK大小进行压缩策略，减小APK安装包大小，更小的安装包更有助于吸引用户安装。前一段时间我司某一App进行APK的瘦身，最终也达到了减小10M的目标，现做一个简单的总结记录。\n\n### 如何着手这个问题？ ###\n\n需要对一个App进行瘦身，首先最重要的就是对App大小有一个大致的了解，最直观看到App的大小就是通过Android Studio自带的Analyzer进行APK的分析。使用方法：\n\n```\n1、将一个apk拖动到Android Studio的编辑器窗口 \n2、在Project窗口中，双击build/output/apks/目录下的apk \n3、在菜单栏中选择选择Build > Analyze APK，然后选择要分析的apk\n```\n\n![图1](https://ae01.alicdn.com/kf/HTB180rja6LuK1Rjy0Fhq6xpdFXaK.jpg)\n\n获取如上图1所示的APK Size分析图之后，我们就可以针对这里面的目录进行针对性的优化。\n\n如图最上方所示的APK Size就是我们应用打包之后的大小，Download Size则是上传到Google Play之后，用户下载的大小。所以我们一般可以只针对前一项的APK Size进行对比。\n\n\n### 分析问题，发掘优化点 ###\n\n从上图Analyzer可以发现，一个APK主要包含如下目录:\n\n- **lib**：包含了一些区分于处理器的编译代码，主要是SO文件，一般里面包含很多子目录，例如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, and mips。\n- **res**：包含了一些不会被编译到resources.arsc的资源文件。如drawable文件、layout文件等。\n- **assets**：包含了一些通过AssetManager能够检索到的资源。如MP3、字体、webp等资源文件。\n- **META-INF**：包含了CERT.SF和CERT.RSA签名文件，还有MANIFEST.MF文件。\n\n除此之外，还包含了如下的文件：\n\n- **resources.arsc**：包括了所有可以被编译的位于res/values/目录下的XML资源。打包工具在打包过程中会把XML的内容编译成二进制的形式，亦或者把相关资源的引用路径编译成二进制，然后整合到该文件里面。例如string文件、layout的路径、图片的路径等。\n\n- **classes.dex**：包含了所有的Java文件编译后的class文件，class文件最终转化成该dex文件。一般文件都比较大，有的App有几个dex文件，这是因为单个DEX文件限制方法数在65536，所以当代码量过大时，就需要通过multiDex进行分包，拆分成多个dex文件，解决这个问题。\n\n- **AndroidManifest.xml**：整合了多个module的AndroidMainifest文件的权限、声明等配置到该文件。\n\n知道了APK的组成部分，那么我们就可以针对这些文件/文件夹进行针对性的优化，每个App都不一样，但是方法都是大同小异，本文讲述瘦身策略也是针对这些目录和文件进行优化，这样可以显得更加有条理性。\n\n#### 1. lib目录优化 ####\n\nAndroid系统现在支持7种CPU架构，每一种都关联着对应的ABI（二进制接口，Application Binary Interface），而每一种ABI都定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库等。所以如果我们的App需要适配不同的CPU架构的话，如下图2所示，就需要放入不同架构的文件夹下都放入不同的so文件，在打包时，这些so都会放在lib目录下。由此，如果我们想减小lib目录的大小，无非就如下一些常见的策略。\n\n![图2](https://ae01.alicdn.com/kf/HTB1VgN2bcfrK1RjSszcq6xGGFXaY.jpg)\n\n- **so裁剪、删除**\n\n对App引入的so文件进行确认哪些是不需要的，哪些是可以进行裁剪压缩的，哪些是可以避免引入的。例如如果引入的so需要下载上传功能而多引入了一个cURL库导致so增大，这时就可以让Java层代码定义接口，让so来调用，从而避免引入cURL库；再如Fresco库，如果不需要webP图，或者不需要webP动图功能，然后减少Fresco库的依赖，同样可以减小so的大小。\n\n- **只保留armeabi或者armeabi-v7a**\n\nAndroid系统现在支持很多种CPU架构（如mips、arm、x86等），市面上主流机型都是arm架构，x86和mips类型极少。所以可以有选择地保留某些架构的so，从而降低lib文件夹的大小。但是我建议你在开始前先对用户手机的cpu型号进行一次统计，分析自身App对应架构手机的占有率，这样你才能大胆的进行操作，一般只保留armeabi或者armeabi-v7a即可。操作也是比较简单，只需要在根目录的build.gradle下配置：\n```\nandroid {\n    buildTypes {\n        ndk {\n            abiFilters \"armeabi-v7a\"\n        }\n    }\n}\n```\n\n如果你的App需要支持多种架构，那么就可以在`abiFilters`里面把多种架构加进去，当然你也可以只保留一种，然后分渠道打包，如Google Play就支持arm和x86等多个渠道打包。\n\n#### 2.res目录优化 ####\n\nres目录一般也是占APK Size大头的一个目录，如下图，这个目录一般都是图片资源占空间比较多，尤其当App为了适配多种分辨率而存放了多套图时，这时候就会导致res目录打下会非常大。而这个目录的优化方式也是比较多，下面就简单列举一下：\n\n![图3](https://ae01.alicdn.com/kf/HTB1wAtZbovrK1RjSspc762zSXXam.png)\n\n- **只保留一套图**\n\n因为Android设备在加载图片时会优先加载对应分辨率文件夹下的图片，如果对应分辨率文件下没有所要的图片，则找高分辨率对应文件夹下的图片。那是不是我们把图片放在最高分辨率的文件夹下就可以了呢？不是的！因为如果这样会导致低分辨率手机加载图片时会消耗更多的内存，而且是指数级别增长的，所以如果盲目地放在一个目录是不合适的。目前不同分辨率对应优先加载的文件夹中图片如下，如果是针对国内用户的App可以只保留xxhdpi目录，而如果是东南亚市场的App则可以只保留xhdpi。\n\n```\n320*240        ldpi\n\n480*320        mdpi\n\n800*480        hdpi\n\n1280*720       xhdpi\n\n1920*1080      xxhdpi\n```\n\n- **非重要图片动态加载**\n\n针对一些非重要的图片，可以选择动态在线加载，严格来说，非首页的图片都可以动态加载，当然，为了提升用户体验，我们会把图片放在本地。但是，一些使用场景非常小或者大小较大的图片，大胆删掉，选择动态加载吧！\n\n- **保真压缩图片**\n\n可以使用一些图片压缩网站或者工具压缩你的资源文件吧，例如TinyPng、ImageOptim、Zopfli、智图等。\n\n- **使用webp替换png**\n\n如果你的App只支持Android4.0以上的话，可以把png格式的图片转为webp，相同画质下体积更小。\n\n- **使用lint删除无用资源**\n\n在多人开发过程中，通常都会有漏删无用资源的问题，图片资源也不例外，例如需要删除一个模块的代码时，很容易就会漏删资源文件，所以可以定期使用lint检测出无用的资源文件，原理这里不作介绍，使用方法非常简单，可以直接在AS里面使用，如下图所示。注意：lint检查出来的资源都是无直接引用的，所以如果我们通过getIdentifier()方法引用文件时，lint也会标记为无引用，所以删除时注意不要删除通过getIdentifier()引用的资源。\n\n\n```\nAnalyze -> Run Inspection by Name -> 输入：Unused resources -> 跳出弹框选择范围即可\n```\n\n- **打开shrinkResources**\n\nshrinkResources是在编译过程中用来检测并删除无用资源文件，也就是没有引用的资源，minifyEnabled 这个是用来开启删除无用代码，比如没有引用到的代码，所以如果需要知道资源是否被引用就要配合minifyEnabled使用，只有两者都为true时才会起到真正的删除无效代码和无引用资源的目的。打开方式也是非常简单，在build.gralde文件里面打开即可：\n\n\n```\nandroid {\n    buildTypes{\n        minifyEnabled true\n        shrinkResources true\n    }\n}\n```\n\n\n#### 3.assests目录优化 ####\n\nassests目录存放的通常是一些通过AssetManager能够检索到的资源，包括MP3、视频、字体、webp的资源，各个App存放内容都很大不相同，列举一些常用的优化方案。\n\n- **删除无用字体**\n\n中文字体一般都比较大，因为字体文件包含了中文好几千个汉字，但是我们实际上在App中并不会全部都使用，甚至我们只用到其中的几个字，这时候我们就可以把字体文件进行删减，在Github上面有一个字体提取工具[FontZip](https://github.com/forJrking/FontZip)，使用方法也是非常简单，有兴趣可以去star一下。\n\n![图4](https://ae01.alicdn.com/kf/HTB1_rzobinrK1Rjy1Xc5jaeDVXaI.gif)\n\n- **动态下载**\n\n一些MP3、视频、Webp等资源可以在使用到时再进行下载，不需要放在本地。\n\n- **对资源进行压缩**\n\n一些MP3、视频、Webp等资源如果必须放在本地，可以压缩成zip文件或者使用7zip进行压缩，在使用到时再进行解压，减小空间的占用。\n\n\n#### 4.META-INF目录 ####\n\n该目录下的MANIFEST.MF、CERT.SF、INDEX.LIST、CERT.RSA等文件主要是存放一些APK文件加密后的信息，用以校验APK的完整性和安全性，这个目录没有太好的优化方式，而且文件一般也比较小，不会超过1M。\n\n\n#### 5.resources.arsc文件压缩 ####\n\n这个文件包含所有可以被编译的位于res/values/目录下的XML资源，如下图5所示是淘宝APK的resources.arsc文件，像图片的引用名字、layout文件的引用名字、string资源等都被编译到了这个文件里面。\n\n![图5](https://ae01.alicdn.com/kf/HTB1oFYFHgHqK1RjSZFE763GMXXaR.png)\n\n所以如果我们需要对resources.arsc文件进行优化，无非就是对路径名字进行混淆，删除无用的资源映射，前者可以使用AndResGuard，后者可以使用lint等进行检测。\n\n- **删除无用的语言**\n\n大部分应用都不需要支持几十种上百种语言，所以在我们引用一些第三方库时（如Google、Facebook的库），它们往往带有上百种多语言资源，而大部分多语言对于我们自己的应用是没有用处的，我们只需要在`build.gralde`里面进行如下配置即可完成无用语言资源的删除，这样在打包的时候就会排除私有项目、android系统库和第三方库中非中文的资源文件了，效果还是比较显著的。\n```\nandroid {\n    //...\n    defaultConfig {\n        // 只保留中文\n        resConfigs \"zh\"\n    }\n}\n```\n\n\n- **使用AndResGuard压缩**\n\n[AndResGuard](https://github.com/shwenzhang/AndResGuard)是一个帮助你缩小APK大小的工具，他的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a。详细使用方法参照Github，很简单有效地减小resources.arsc文件大小。如下图6和图7所示，图6是压缩前的效果，图7是压缩完的效果，如果是资源比较多的App，压缩效果也是立竿见影。\n\n![图6](https://ae01.alicdn.com/kf/HTB1G__HbjDuK1RjSszd760GLpXa9.png)\n![图7](https://ae01.alicdn.com/kf/HTB1iLbKbjzuK1RjSspp760z0XXaq.png)\n\n使用方法也是非常简单，在`build.gradle`文件中进行如下配置即可：\n\n\n```\nandResGuard {\n    mappingFile = null\n    use7zip = true\n    useSign = true\n    keepRoot = false\n    whiteList = [\n        //for your icon\n        \"R.drawable.icon\",\n        //for fabric\n        \"R.string.com.crashlytics.*\",\n        //for umeng update\n        \"R.string.umeng*\",\n        \"R.string.UM*\",\n        \"R.layout.umeng*\",\n        \"R.drawable.umeng*\",\n        //umeng share for sina\n        \"R.drawable.sina*\"\n    ]\n    compressFilePattern = [\n        \"*.png\",\n        \"*.jpg\",\n        \"*.jpeg\",\n        \"*.gif\",\n        \"resources.arsc\"\n    ]\n     sevenzip {\n         artifact = 'com.tencent.mm:SevenZip:1.1.9'\n         //path = \"/usr/local/bin/7za\"\n    }\n}\n```\n\n\n#### 6.dex文件压缩 ####\n\nDalvik是Android平台运行时的环境，但是Dalvik虚拟不支持直接执行Java的字节码，所以会对编译生成的 .class 文件进行翻译、重构、解释、压缩等处理，这个处理过程是由 dx 进行处理，处理完成后生成的产物会以 .dex 结尾，称为Dex文件。\n\n像淘宝、微信这些App，如果我们分析它们的APK可以发现，它们有多个Dex文件，如下图8所示，这是因为单个Dalvik Excutable（DEX）字节码文件内的方法数不可以超过65536个，所以需要DEX分包配置来避免这个限制，使应用能够构建并读取DEX文件。\n\n![图8](https://ae01.alicdn.com/kf/HTB1CvjLbojrK1RkHFNRq6ySvpXaC.jpg)\n\n- **Proguard代码混淆**\n\nProguard是一款免费的Java类文件压缩器、优化器和混淆器，Android Studio已经集成了这个工具，只要经过简单的配置，即可完成，如下代码所示，在build.gradle里面设置`minifyEnabled `为ture，同时在`proguardFiles`指向proguard的规则文件即可。\n\n\n```\nandroid {\n    buildTypes{\n        minifyEnabled true\n        proguardFiles 'proguard.cfg'\n    }\n}\n```\n\n### 总结 ###\n\nApp瘦身是一个长期的过程，建议可以进行每个版本对APK大小进行监控，列出增加和减小的点，做到持续的统计和追踪，从而给公司带来效益。","tags":["性能优化","APK瘦身"],"categories":["Android"]},{"title":"Hexo你所不知道的奇淫巧技【持续更新】","url":"/2018/01/09/Hexo你所不知道的奇淫巧技【持续更新】/","content":"\n在我们搭建完了博客之后，我们作为一名有理想有追求的程序员，当然是想让我们的博客更加具备我们自己的Style，但是无疑文字是苍白的，所以我们可以结合一些奇淫巧技，为我们的博客增添色彩~\n\n## 1. 插入图片 ##\n\n![](http://onq81n53u.bkt.clouddn.com/tmac.jpg)\n\n以我的小麦麦为例，首先在网上找到他的图片，然后右键复制图片地址，替换掉下面的图片链接，中括号里面是描述，有些网站显示不了描述，像简书就可以，小括号里面就是图片链接。\n\n\t![T-Mac](http://onq81n53u.bkt.clouddn.com/tmac.jpg)\n\n\n\n\n\n## 2. 插入音乐 ##\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86   \n    src=\"http://music.163.com/outchain/player?type=2&id=408522142&auto=0&height=66\">  \n</iframe> \n\n例如插入我们常用的网易云音乐，可以网易云在线版找到你要播放歌的id，替换掉下面id即可，然后放在你的markdown写的文章里面。\n\n\t<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86   \n\t    src=\"http://music.163.com/outchain/player?type=2&id=408522142&auto=1&height=66\">  \n\t</iframe> \n\n## 3. 插入视频 ##\n\n<iframe   \n    height=498 width=510   \n    src=\"http://player.youku.com/embed/XNDI1ODk4Mzgw\"   \n    frameborder=0 allowfullscreen>  \n</iframe> \n\n就拿我母校的外国语学校的微视频为栗子啦~先把视频放到优酷上面，在网页版有个分享按钮，点开之后有个通用代码，没错就是下面这一段，然后需要格式化一下代码哦，不然显示不出来。\n\n\t<iframe   \n\t    height=498 width=510   \n\t    src=\"http://player.youku.com/embed/XNDI1ODk4Mzgw\"   \n\t    frameborder=0 allowfullscreen>  \n\t</iframe> \n\n其实要是学过点html的童鞋都可以看出来，这个iframe就是加载了一个网页而已，然后src就是优酷给我们提供的只包含该视频的一个网页，然后我们的iframe把这个网页加载出来，所以可以得知，Markdown的语法已经支持了iframe这个标签，当然，更多的特性需要大家一起发掘~\n\n## 4. 未完待续.. ##","tags":["奇淫巧计"],"categories":["学习"]},{"title":"share-生活在孤独中前行","url":"/2018/01/05/share-生活在孤独中前行/","content":"\n*这是我某天听电台的时候听到的一篇文章，其中的一些观点挺赞同的，随着年龄的增长，发现孤独才是自己生活最常见的事情，即便你经常和朋友玩，抑或在恋爱、结婚，你的生活被喧嚣充斥着，但是当你静下来的时候，你的内心就是孤独的，孤独并不可怕，可怕的是被孤独击败，我们需要学会的是战胜孤独。这时，你也许发现孤独也是一件很好的事情吧。*\n\n<iframe frameborder=\"yes\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=65  \n    src=\"http://blog-lijianchang.oss-cn-beijing.aliyuncs.com/blog/share-%E7%94%9F%E6%B4%BB%E5%9C%A8%E5%AD%A4%E7%8B%AC%E4%B8%AD%E5%89%8D%E8%A1%8C/%E7%94%9F%E6%B4%BB%E5%9C%A8%E5%AD%A4%E7%8B%AC%E4%B8%AD%E5%89%8D%E8%A1%8C%7E1.mp3\">  \n</iframe>  \n\n\n> 生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。——莫泊桑\n\n以这一句话开始，是因为看了高木直子的《一个人住第五年》。都说人是慢慢成长的，其实不是，人是瞬间长大的，就像是突然间沉淀一般，突然不会谈恋爱了或者说不想谈恋爱了，一个人生活单一却也不会觉得无聊，即便很多时候还是会迷茫却也不会觉得烦躁了。去年的今天我在不一样的城市，背着不一样的书包，留着不一样的发型，走着不一样的路，想着不一样的事情，有着不一样的心思，谁说改变要十年呢。或者说，这一秒的想法和上一秒的想法就不一样，这个世界是瞬间变化的，运转速度是那么快，没有人在意你是不是一个人。而我呢，就是一个人，默默地在做自己的事，感受着生活中的变化，也感受着自己的变化，在不断的变化中，寻找最佳的结合点和平衡点。信奉一句话：变化中求生存。专注和节奏是生活的主旋律。\n\n身边的牛人倒是不少，像是神抵一样的存在，我也只是羡慕想着反正自己也不会变成那样的人，直到有一天跟国内比较有影响力28岁的年轻总裁聊天，才知道原来他也有看不进去书，经常想方案想到撞墙的时候，我们都忘了他们是用怎么样的一个代价才换取来了这样的一个人生。他说，如果你想要去实现梦想，孤独是你的必修课。如果不能沉下心来，就没有办法去实现它，因为那绝对不是一件容易的事情，孤独能让你更坚强，你必须找到自己的生活节奏。\n\n最近迷上一个人到处走，算不上旅行只是周围到处走一走，倒也不会花上太多时间准备，起身就走了。我不会带上相机只是有兴致了拿出手机拍一拍，音乐倒是我走到哪里都不能丢的东西，每个月都会去听几场音乐会，只有音乐，能让看似漫长的等待变成曼妙的旅程，似乎自己跟整个世界都没有关系，只想当一片没有名字的云，徜徉在不知道名字的风景里。\n我们都会找到自己的生活节奏，然后沉溺其中无法自拔。\n\n曾经学生时代很少去图书馆，觉得那种“每个星期读一本书”对于我来讲有点勉强。但之后的某一天我陪朋友去图书馆，他是一个借书就不会停的人，我也就跟着借了几本。回到家里看微博人人又觉得心里空当当的，索性就拿起书来看，也是在那一天我才发现，其实每个星期看一本书没那么难，那天我一下子把书看完，才觉得这样子的生活是充实的。所以我喜欢读书，读很多书，尽管现在时间很紧，有时候忙得让自己无法开胶，但每天还是会抽出一点时间来，看看书。\n\n要么读书，要么旅行，身体和灵魂，必须有一个在路上。\n\n我告诉自己现实容不得你拖延，拖延只会让我变得更焦虑而已，所以刚开始的时候我规定自己每天提早上床半小时，看上几十页书，很快就变成习惯了。有的时候我不得不感叹如果真的去做一件事情的话，那么这件事情没有那么难。当你真的想要做一件事情的时候，整个世界都会来协助你，就是这种感觉。想起了09年艺考备战时，想起了面试节目时，经常告诉自己的一句话：当你只有一个目标时，全世界都会为你让路。\n\n一个喜欢冒险和旅游的朋友说，只要出发，就能到达，你不出发，就哪里也去不了。如果你不能沉下心来，就什么也做不到。出发永远是最有意义的事，去做就是了。一本书买了不看只是几张纸，公开课下了不看也只是一堆数据，不去看就没有任何意义，反而徒增焦虑，行动力才是最关键的。\n\n你也许也是这样，当你渴望找个人交谈的时候，你们却没有谈什么，于是发现有些事情是不能告诉别人的，有些事情是不必告诉别人的，有些事情是根本没有办法告诉别人的，而有些事情即使告诉了别人，你也会马上后悔，那么最好的办法就是静下来，真正能平静自己的只有自己。\n\n没有人能免得了孤独，与其逃避它不如面对它。孤独并不是一件那么糟糕的事情，与嘈杂相比，一个人生活倒显得自得地多，倒也可以变成一种享受。或许至少需要那么一段时间，几年或几个月，一个人生活，不然怎么能找到自己的节奏知道自己想要什么。这是属于你自己的东西，是你的一部分，你听音乐时，坐地铁时，一个人走在马路上时，它就会流淌出来，让我觉得这个世界似乎在以另外一种形式存在着，我能够清晰地听到自己，不断地在和自己对话交流。所以，我很喜欢独处，喜欢一个人漫无目的的随便走走。\n\n我们都生活在一个不那么如意的世界，当乌云密布我们就摇曳，但阳光总有一天会到来，等阳光照到你的时候，记得开出自己的花就行了，那个你与生俱来的梦想。有的时候梦想很远，有的时候梦想很近，但它总会实现的。我想一个人最好的样子就是平静一点，哪怕一个人生活，穿越一个又一个城市，走过一个又一条街道，仰望一片又一片天空，见证一次又一次别离。\n\n即便世界与我为敌，只要心还透明，就能折射希望。\n\n接下来说说“选择”，选择，是一门艺术，一种技巧，一种生活的情调。什么都有正反两面，有些是我们能把握控制的，有些是我们不能左右的，但是我们有选择的权利，可以选择我们自己的生活。小处说，可以选择一种心情，一件衣服，甚至中午我们要吃什么饭，大处讲，我们可以选择一段感情，一种方式，一种习惯，一种性格，一种态度，一种人生。而这一切的出发点都是我们的内心，依据内心和环境而做出的选择。选择的任何一种形式都要为我们的结果服务的，不然选择就毫无意义，通常我们会采用两种方式思考问题和做出选择：基于自己的真实想法和基于事情的后果。但是都要归到一个点上，你要为你的选择买单。\n\n如果你感觉你会后悔，那么你就不要去选择；如果你选择了，你就永远不要后悔。\n\n然后就是“比较”比较，是一门哲学。比较就像一面镜子，可以知得失，知利弊，知不足，知缺点也知优点。比较是自己的一部历史，给你经验，给你教训，让你更加了解你自己，进而完善自己。在和周围的比较时，别忘了和昨天的你做比较，这样会进步更快。\n\n“变化”，上边已经提到一点，变化其实才是生活的实质，人是在变化的，生活是在变化的，社会是在变化的，整个世界也在不断的变化，而你要不要变化？？？要不要去适应这个世界，赶上节奏？？？当你一种不好的习惯或者性格，把你的而生活搞得很糟糕时，你还在怂恿它，不想改变，为什么？？你已经很清洗地认识到它的弊端了，为什么不变？？当它直到有一天，事情搞到无法挽救的地步，你才想起要改变，是不是有点晚了。人的惰性和致命弱点。这或许我们每个人都经历过，才会一步一步长大成熟。穷则思变，穷则生变，有变才有进步。变，是一种考验和磨练，让你坚强，让你自信，让你成熟。\n\n一个人的思想和认识的变化对他来说，很重要。只有思想上的变革才会有行为上的变化。其实也就是我们所说的想与做的问题，但是一般人所说的想，只是随便的想一想，并没有深入到根本本质的东西，没有认真的分析，要做成一件事，需要什么样的思想、认识，需要什么环境、条件，还有需要自身什么精神或者品质、习惯（如坚持、吃苦、坚强、勤奋、激情等等）这可以说也是一个逻辑思维的过程，但却是做成一件事必不可缺少的过程。想起来电视上狄仁杰说过的一句话：想做成一件事要有三断——判断、推断、果断。也如现在人们所说的三力——判断力、分析力、执行力，所以什么事都不是那么简简单单容易的就做成的，需要你做的很多。\n\n对于“简单”来说，不同的人有不同的认识，一千个读者一千个哈姆雷特。真正的大家、智者、老者所认为的简单，其实是不简单。简单是从复杂中提炼出来的，没有经过复杂哪里来的简单。与其说简单是一种幸福，不如说经历复杂是一种幸福。路遥《平凡世界》上有一句关于幸福的解释，值得借鉴：幸福不只是吃饱穿暖，而是勇敢地去战胜困难，一点一点地不断超越自己！\n\n“平衡”我对平衡感要求很高的，这种思想是我从生态学上学到的，我认为生态学中有一种思想就是平衡和和谐。任何一个环境，包括我们人类所生活的社会环境，都需要在一个平衡和谐的状态下才能持久下去，不然都会被淘汰的，针对一个人个体上说也是一样的，你如果不能保持你内心的一种平衡，你肯定会抱怨的，每个人都一样，都会这样的。那我们该怎样做，才能是我们的身与心、内与外的平衡和谐呢。这是我们要找的东西，因人而异，要量体裁衣。\n\n那么孤独是人生的一部分，缺少了孤独，似乎人生也就不完美了，所以我们应该习惯孤独，爱上孤独，它能告诉你很多人生的秘密。相信我。\n\n","tags":["孤独"],"categories":["阅读"]},{"title":"用RecyclerView做一个小清新的Gallery效果","url":"/2017/12/15/用RecyclerView做一个小清新的Gallery效果/","content":"\n## 一、简介 ##\nRecyclerView现在已经是越来越强大，且不说已经被大家用到滚瓜烂熟的代替ListView的基础功能，现在RecyclerView还可以取代ViewPager实现Banner效果，当然，以下做的小清新的Gallery效果也是类似于一些轮播图的效果，如下图所示，这其中使用到了24.2.0版本后RecyclerView增加的SnapHelper这个辅助类，在实现以下效果起来也是非常简单。所以这也是为什么RecyclerView强大之处，因为Google一直在对RecyclerView不断地进行更新补充，从而它内部的API也是越来越丰富。\n\n\n![小清新的Gallery水平滑动效果](https://user-gold-cdn.xitu.io/2017/12/13/1604f61b7219464a?w=201&h=358&f=gif&s=3031397)\n\n![小清新的Gallery垂直滑动效果](https://user-gold-cdn.xitu.io/2017/12/13/1604f61b781841cc?w=206&h=366&f=gif&s=2045166)\n\n\n那么我们从水平滑动为例，我们细分为以下几个小问题：\n\n1. 每一次滑动都让图片保持在正中间。 \n2. 第一张图片的左边距和最后一张的右边距需要保持和其他照片的左右边距一样。\n3. 滑动时，中间图片滑动到左边时从大变小，右边图片滑动到中间时从小变大。\n4. 背景实现高斯模糊。\n5. 滑动结束时背景有一个渐变效果，从上一张图片淡入淡出到当前图片。\n\n## 二、实现思路 ##\n\n解决以上问题当然也不难，我们分步来讲解下实现思路：\n\n### (1) 每一次滑动都让图片保持在正中间 ### \n\n保持让图片保持在正中间，正如简介中所说，在ToolsVersion24.2.0之后，Google给我们提供了一个`SnapHelper`的辅助类，它只需要几行代码就能帮助我们实现滑动结束时保持在居中位置：\n\n\tLinearSnapHelper mLinearySnapHelper = new LinearSnapHelper();\n\tmLinearySnapHelper.attachToRecyclerView(mGalleryRecyclerView);\n\n`LinearSnapHelper`类继承于`SnapHelper`，当然`SnapHelper`还有一个子类，叫做`PagerSnapHelper`。它们之间的区别是，`LinearSnapHelper`可以使RecyclerView一次滑动越过多个Item，而`PagerSnapHelper`像ViewPager一样限制你一次只能滑动一个Item。\n\n### (2) 第一张图片的左边距和最后一张的右边距需要保持和其他照片的左右边距一样 ###\n\n\n\n由于第0个位置，和最后一个位置的图片比较特殊，其他图片都默认设置他们的**页边距**和**左右图片的可视距离**，由于第0页左边没有图片，所以左边只有1倍页边距，这样滑动到最左边时看起来就会比较奇怪，如下图所示。\n\n![](https://user-gold-cdn.xitu.io/2017/12/13/1604f61b72460f9a?w=387&h=475&f=png&s=16085)\n\n让第0位置的图片左边保持和其他图片一样的距离，那么就需要动态设置第0位置图片的左边距为**2倍页边距 + 可视距离**。同理，最后一张也是做同样的操作。\n\n动态修改图片的`LayoutParams`，由于RecyclerView对Holder的复用机制，我们最好不要在Adapter里面动态修改，这样子首先不够优雅，这里感谢`@W_BinaryTree`的建议，我们给RecyclerView添加一个自定义的Decoration会让我们的代码更加优雅，只需要重写`RecyclerView.ItemDecoration`里面的`getItemOffsets(Rect outRect, final View view, final RecyclerView parent, RecyclerView.State state)`方法，并在里面设置每一页的参数即可，修改如下：\n\t\n\tpublic class GalleryItemDecoration extends RecyclerView.ItemDecoration {\n\t    int mPageMargin = 0;          // 每一个页面默认页边距\n\t    int mLeftPageVisibleWidth = 50; // 中间页面左右两边的页面可见部分宽度\n\n\t    public static int mItemComusemX = 0;  // 一页理论消耗距离\n\n\t\n\t\t@Override\n\t    public void getItemOffsets(Rect outRect, final View view, final RecyclerView parent, RecyclerView.State state) {\n\t        super.getItemOffsets(outRect, view, parent, state);\n\t    \t// ...\n\n\t    \t// 动态修改页面的宽度\n\t    \tint itemNewWidth = parent.getWidth() - dpToPx(4 * mPageMargin + 2 * mLeftPageVisibleWidth);\n\t    \n\t\t\t// 一页理论消耗距离\n\t        mItemComusemX = itemNewWidth + OsUtil.dpToPx(2 * mPageMargin);\n\n\t        // 第0页和最后一页没有左页面和右页面，让他们保持左边距和右边距和其他项一样\n\t        int leftMargin = position == 0 ? dpToPx(mLeftPageVisibleWidth + 2 * mPageMargin) : dpToPx(mPageMargin);\n\t        int rightMargin = position == itemCount - 1 ? dpToPx(mLeftPageVisibleWidth + 2 * mPageMargin) : dpToPx(mPageMargin);\n\t    \n\t    \t// 设置参数\n\t    \tRecyclerView.LayoutParams lp = (RecyclerView.LayoutParams) itemView.getLayoutParams();\n\t        lp.setMargins(leftMargin, 0, rightMargin, 0);\n\t        lp.width = itemWidth;\n\t        itemView.setLayoutParams(lp);\n\t    \n\t    \n\t    \t// ...\n\t\n\t\t}\n\t\n\t\tpublic int dpToPx(int dp) {\n\t        return (int) (dp * Resources.getSystem().getDisplayMetrics().density + 0.5f);\n\t    }\n\t}\n\n然后，把`GalleryItemDecoration`传入即可：\n\n\tmGalleryRecyclerView.addItemDecoration(new GalleryItemDecoration());\n\n\n\n\n### (3) 滑动时，中间图片滑动到左边时从大变小，右边图片滑动到中间时从小变大 ###\n\n这个问题涉及到比较多的问题。\n\n**(a) 获取滑动过程中当前位置。**\n\n首先，RecyclerView当前的API，并不能让我们在滑动的过程中，简单地获取到我们图中效果中间图片的位置，或许你会说，可以通过\n`mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition()`能拿到RecyclerView中第一个可见的位置，但是通过效果可以知道，我们每一个张照片（除去第一张和最后一张）左右两边都是有前一张照片和最后一张照片的部分内容的，所以需要做区分判断是否是中间的照片还是第一张亦或最后一张，然后返回`mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition() + 1`或者其他。 那么这样又会引出一个问题，当我们把前后照片展示的宽度设置成可配置，即前后照片的露出部分宽度是可配置，那么当我们把屏幕不显示前后照片遗留部分在屏幕的话，那么我们这一个方法又不能兼容了，所以通过这一个方法来获取，或许不那么靠谱。\n\n我们可以这样来计算出比较准确的位置。在RecyclerView中，我们可以监听它的滑动事件：\n\n\t// 滑动监听\n\tmGalleryRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {\n\t    @Override\n\t    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\n\t        super.onScrollStateChanged(recyclerView, newState);\n\t    }\n\t\n\t    @Override\n\t    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n\t        super.onScrolled(recyclerView, dx, dy);\n\n\t\t\t// 通过dx或者dy来计算位置。 \n\t    }\n\t});\n\n里面有一个`onScrolled(int dx, int dy)`方法，这里面的dx，dy非常有用。首先，通过判断dx，dy是否大于0可以判断它是上、下、左、右滑动，dx > 0右滑，反之左滑，dy > 0 下滑，反之上滑（当然，我这里的滑动是相对于RecyclerView，即列表的滑动方向，手指的滑动方向和这里相反）。其次，dx和dy还能监听每一次滑动在x，y轴上消耗的距离。\n\n举个例子，当我们迅速至列表右边时，`onScrolled(int dx, int dy)`会不断被调用，通过在方法里面Log输出，你会看到不断输出dx的值，而且他们的大小都是无规律的，而这里的dx就是每一次`onScroll`方法调用一次，RecyclerView在x轴上的消耗距离。\n\n所以我们可以通过一个全局变量`mConsumeX`来累加所有dx，当这样我们就可以知道当前RecyclerView滑动的总距离。而我们Demo中每移动到下一张照片的距离(即如下图中所示的**移动一页理论消耗距离**)是一定的，那么就可以通过`当前位置 = mConsumeX / 移动一张照片所需要的距离`来获取滑动结束时的位置了。\n\n![RecyclerView距离示意图](https://user-gold-cdn.xitu.io/2017/12/13/1604f61b6e561f70?w=825&h=773&f=png&s=42932)\n\n\t/**\n\t * 获取位置\n\t *\n\t * @param mConsumeX      实际消耗距离\n\t * @param shouldConsumeX 移动一页理论消耗距离\n\t * @return\n\t */\n\tprivate int getPosition(int mConsumeX, int shouldConsumeX) {\n\t    float offset = (float) mConsumeX / (float) shouldConsumeX;\n\t    int position = Math.round(offset);        // 四舍五入获取位置\n\t    return position;\n\t}\n\n**(b) 根据位置获取当前页的滑动偏移率**\n\n当我们可以准确拿到当前位置时，我们就需要明确一下几个概念。\n\n`总的偏移距离`：意思是从第一个位置移动到现在当前位置偏移的总距离，即dx的累加结果（也就是上述的mConsumX）。\n\n`当前页偏移距离`：意思是从上一个位置移动到当前位置偏移距离。\n\n`总的偏移率`：意思是 总的偏移距离 / 移动一页理论消耗距离。\n\n`当前页的偏移率`：意思是 当前页偏移距离 / 移动一页理论消耗距离。\n\n\n![](https://user-gold-cdn.xitu.io/2017/12/13/1604f61b758abedb?w=1072&h=934&f=png&s=46504)\n\n我们都知道，获取当前位置方法里面有一个 \n\n\tfloat offset = (float) mConsumeX / (float) shouldConsumeX;\n\n它的意思就是总的偏移率，例如图中我们当前位置是3，我们从3移动到4时，`onScroll`方法会不断被调用，那么这个offset就会不断变化，从3.0逐渐增加一直到4.0，图中此时的offset大概是3.2左右，我们知道这一个有什么用呢？试想一下，offset是一个浮点型数，将它向下取整，那就是变成3了，那么3.2 - 3 = 0.2就是我们当前页的偏移率了。而我们通过偏移率就可以动态设置图片的大小，就形成了我们这个问题中所说的图片大小变化效果。所以这里的关键就是获取到`当前页的偏移率`。\n\n\t@Override\n\tpublic void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n\t\tsuper.onScrolled(recyclerView, dx, dy);\n\n\t    // ...\t\n\n\n\t    // 移动一页理论消耗距离\n        int shouldConsumeX = GalleryItemDecoration.mItemComusemX;\n\n\n        // 获取当前的位置\n        int position = getPosition(mConsumeX, shouldConsumeX);\n\t\n\t    // 位置浮点值（即总消耗距离 / 每一页理论消耗距离 = 一个浮点型的位置值）\n\t    float offset = (float) mConsumeX / (float) shouldConsumeX;     \n\t\n\t    // 避免offset值取整时进一，从而影响了percent值\n\t    if (offset >= mGalleryRecyclerView.getLinearLayoutManager().findFirstVisibleItemPosition() + 1 && slideDirct == SLIDE_RIGHT) {\n\t        return;\n\t    }\n\t\n\t    // 当前页的偏移率\n\t    float percent = offset - ((int) offset);\n\n\n        // 设置动画变化\n\t    setAnimation(recyclerView, position, percent);\n\n\t    // ...\n\t\n\t}\n\n**(c) 根据偏移率实现动画**\n\n现在我们拿到了偏移率，就可以动态修改它们的尺寸大小了，首先，我们需要拿到当前View，前一个View和后一个View，并同时对它们做Scale伸缩。即上面的`setAnimation(recyclerView, position, percent)`方法里面进行动画操作。\n\n        View mCurView = recyclerView.getLayoutManager().findViewByPosition(position);       // 中间页\n        View mRightView = recyclerView.getLayoutManager().findViewByPosition(position + 1); // 左边页\n        View mLeftView = recyclerView.getLayoutManager().findViewByPosition(position - 1);  // 右边页\n\n认真观察图中变化，两种变化：\n\n1. 位置的变化：第一张图片是从mCurView慢慢变成mLeftView，而第二张图片是从mRightView慢慢变成mCurView。\n2. 大小变化：第一张图是从大变小，第二张图是从小变大。\n\n理解了以上的变化之后，我们就可以做动画了。\n\n![](https://user-gold-cdn.xitu.io/2017/12/13/1604f61b7472c6f0?w=202&h=366&f=gif&s=1395373)\n\n首先说明一点，大家观察我的`getPosition(mConsumeX, shouldConsumeX)`方法，里面的实现是，当一页滑动的偏移率超过了0.5之后，position就会自动切换到下一页。当然你的实现逻辑不一样，那么后面你的设置动画的方法就不一样。为什么需要明确这一点呢？因为当我滑动超过图片超过它的一半宽度之后，上面的mCurView就会切换成下一张图片了，所以我在设置动画的方法里以0.5为一个临界点，因为0.5临界点的两边，`mCurView`，`mRightView`，`mLeftView`的指向都已经不一样了。\n\n假如我们定义大小变化因子 `float mAnimFactor = 0.2f`，它的意思就是控制我们的图片从1.0伸缩至0.8。以上图为例，当percent <= 0.5时，`mCurView`的ScaleX和ScaleY从大慢慢变小，至于这个变化范围，就根据我们定义的变化因子和percent来修改；而当percent > 0.5时，刚才那个View就变成了`mLeftView`，此时我们继续刚才的操作，整个过程我们就实现了第一张图片的Scale从1.0变化到了0.8。而另外两张图片也是同理，大概代码逻辑如下：\n\n\n\tprivate void setBottomToTopAnim(RecyclerView recyclerView, int position, float percent) {\n        View mCurView = recyclerView.getLayoutManager().findViewByPosition(position);       // 中间页\n        View mRightView = recyclerView.getLayoutManager().findViewByPosition(position + 1); // 左边页\n        View mLeftView = recyclerView.getLayoutManager().findViewByPosition(position - 1);  // 右边页\n\n\n        if (percent <= 0.5) {\n            if (mLeftView != null) {\n\t\t\t\t// 变大\n                mLeftView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor);\n                mLeftView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor);\n            }\n            if (mCurView != null) {\n\t\t\t\t// 变小\n                mCurView.setScaleX(1 - percent * mAnimFactor);\n                mCurView.setScaleY(1 - percent * mAnimFactor);\n            }\n            if (mRightView != null) {\n\t\t\t\t// 变大\n                mRightView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor);\n                mRightView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor);\n            }\n        } else {\n            if (mLeftView != null) {\n                mLeftView.setScaleX(1 - percent * mAnimFactor);\n                mLeftView.setScaleY(1 - percent * mAnimFactor);\n            }\n            if (mCurView != null) {\n                mCurView.setScaleX((1 - mAnimFactor) + percent * mAnimFactor);\n                mCurView.setScaleY((1 - mAnimFactor) + percent * mAnimFactor);\n            }\n            if (mRightView != null) {\n                mRightView.setScaleX(1 - percent * mAnimFactor);\n                mRightView.setScaleY(1 - percent * mAnimFactor);\n            }\n        }\n    }\n\n### (4)背景实现高斯模糊 ###\n\n高斯模糊有挺多种实现方法的，Google一下就出来了。但是还是推荐Native层的实现算法，因为Java层的实现对性能影响实在太大了，例子里使用的是`RenderScript`，当然是参考博主`湫水`的[教你一分钟实现动态模糊效果](http://wl9739.github.io/2016/07/14/%E6%95%99%E4%BD%A0%E4%B8%80%E5%88%86%E9%92%9F%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C/)，大家感兴趣可以过去看看，用法也是非常简单。直接调用`blurBitmap(Context context, Bitmap image, float blurRadius)`方法即可。\n\n\tpublic class BlurBitmapUtil {\n\t    //图片缩放比例\n\t    private static final float BITMAP_SCALE = 0.4f;\n\t\n\t    /**\n\t     * 模糊图片的具体方法\n\t     *\n\t     * @param context 上下文对象\n\t     * @param image   需要模糊的图片\n\t     * @return 模糊处理后的图片\n\t     */\n\t    public static Bitmap blurBitmap(Context context, Bitmap image, float blurRadius) {\n\t        // 计算图片缩小后的长宽\n\t        int width = Math.round(image.getWidth() * BITMAP_SCALE);\n\t        int height = Math.round(image.getHeight() * BITMAP_SCALE);\n\t\n\t        // 将缩小后的图片做为预渲染的图片\n\t        Bitmap inputBitmap = Bitmap.createScaledBitmap(image, width, height, false);\n\t        // 创建一张渲染后的输出图片\n\t        Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap);\n\t\n\t        // 创建RenderScript内核对象\n\t        RenderScript rs = RenderScript.create(context);\n\t        // 创建一个模糊效果的RenderScript的工具对象\n\t        ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));\n\t\n\t        // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间\n\t        // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去\n\t        Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap);\n\t        Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap);\n\t\n\t        // 设置渲染的模糊程度, 25f是最大模糊度\n\t        blurScript.setRadius(blurRadius);\n\t        // 设置blurScript对象的输入内存\n\t        blurScript.setInput(tmpIn);\n\t        // 将输出数据保存到输出内存中\n\t        blurScript.forEach(tmpOut);\n\t\n\t        // 将数据填充到Allocation中\n\t        tmpOut.copyTo(outputBitmap);\n\t\n\t        return outputBitmap;\n\t    }\n\t}\n\n这个方法只要传入Context，Bitmap，和一个模糊程度即可，然后返回一个高斯模糊后的Bitmap给我们，我们只需要将RecyclerView的父布局设置背景为这个Bitmap即可。\n\n### (5)滑动结束时背景有一个渐变效果，从上一张图片淡入淡出到当前图片 ###\n\n实现这个效果最好不要使用Tween动画，因为它的实现效果比较生硬，使用`TransitionDrawable`会让效果更佳接近淡入淡出效果。那我们怎么记录前后两个位置的照片呢？方法很多种，这里就使用了一个Map<String, Drwable>来记录每一次显示的图片，在它切换到下一个图片时，便从上一次记录的图片淡入淡出到本次的图片。\n\n\t// 获取当前位置的图片资源ID\n\tint resourceId = ((RecyclerAdapter) mRecyclerView.getAdapter()).getResId(mRecyclerView.getScrolledPosition());\n\t// 将该资源图片转为Bitmap\n\tBitmap resBmp = BitmapFactory.decodeResource(getResources(), resourceId);\n\t// 将该Bitmap高斯模糊后返回到resBlurBmp\n\tBitmap resBlurBmp = BlurBitmapUtil.blurBitmap(mRecyclerView.getContext(), resBmp, 15f);\n\t// 再将resBlurBmp转为Drawable\n\tDrawable resBlurDrawable = new BitmapDrawable(resBlurBmp);\n\t// 获取前一页的Drawable\n\tDrawable preBlurDrawable = mTSDraCacheMap.get(KEY_PRE_DRAW) == null ? resBlurDrawable : mTSDraCacheMap.get(KEY_PRE_DRAW);\n\t\n\t/* 以下为淡入淡出效果 */\n\tDrawable[] drawableArr = {preBlurDrawable, resBlurDrawable};\n\tTransitionDrawable transitionDrawable = new TransitionDrawable(drawableArr);\n\tmContainer.setBackgroundDrawable(transitionDrawable);\n\ttransitionDrawable.startTransition(500);\n\t\n\t// 存入到cache中\n\tmTSDraCacheMap.put(KEY_PRE_DRAW, resBlurDrawable);\n\n## 更多 ##\n\n以上所讲的都是实现的一个思路，虽然效果和小清新搭不上关系哈，但是配了几张小清新的图片还是让我们的程序员生活增添一丝精彩。其实大家实现了基础效果之后，还可以深挖更多辅助功能，例如不同的切换效果，支持横屏，动态修改滑动速度等，相信这个过程可以让你收获良多。\n\nGithub：[Recyclerview-Gallery](https://github.com/ryanlijianchang/Recyclerview-Gallery)\n\n","tags":["RecyclerView"],"categories":["学习"]},{"title":"Android优化方案之--Fragment的懒加载实现","url":"/2017/08/24/Android优化方案之--Fragment的懒加载实现/","content":"\n# 一、背景 #\n\n在Android应用中，ViewPager是我们不可避免使用的一个控件，因为它可以使我们在占用较少空间的同时，增强内容的丰富性，同时以其内部流淌着Google的血液，所以它几乎成了每一个App的标配控件。但是，假如ViewPager的每一个Fragment都需要通过网络拉取数据加载，而ViewPager是默认加载前两项的，所以在很容易造成网络丢包或者网络堵塞等问题，所以Fragment使用懒加载是非常有必要的。\n\n举个栗子：\n\n![image](http://onq81n53u.bkt.clouddn.com/s.jpg)\n\n如上图所示，我们有两个大的Tab：人物和风景。而人物Tab下有三个Tab：美女、帅哥、萌娃三个Tab，风景Tab下有：北京、香港、上海三个Tab。假如当App刚启动时，执行的生命周期如下：\n\n![image](http://onq81n53u.bkt.clouddn.com/ssss.jpg)\n\n我们可以看到，App会默认加载美女和帅哥两个Fragment，并且它们的生命周期都执行到onStar（）方法，同时加载两个Fragment，假如我们在Fragment加载的时候拉取网络数据，那么就会造成如上所说的网络丢包或者网络堵塞等问题，所以我们为了避免这个问题，就需要实现Fragment的懒加载，当我们对Fragment可见的时候，再进行网络加载数据。\n\n# 二、实现Fragment懒加载 #\n\n针对背景讨论的问题，我们最终要实现的目标就是，当Fragment对我们可见时，我们才进行网络加载，然后再解析数据，更新UI。针对上面的Demo，我们需要做到如下效果：\n\n![image](http://onq81n53u.bkt.clouddn.com/pic11111.gif)\n\n要实现起来其实也并不复杂，在Fragment中有一个`setUserVisibleHint`这个方法，而且这个方法是优于onCreate()方法的，所以也可以作为Fragment的一个生命周期来看待，它会通过isVisibleToUser告诉我们当前Fragment我们是否可见，我们可以在可见的时候再进行网络加载。\n```\npublic void setUserVisibleHint(boolean isVisibleToUser)\n```\n\n当我们在`setUserVisibleHint`方法中进行Log输出时，我们可以看到：\n\n![image](http://onq81n53u.bkt.clouddn.com/70970-a0b03ff409e905014643d270342b8634.jpg)\n\n只有可见时，我们isVisibleToUser为true，否则为false。所以我们可以重写`setUserVisibleHint`方法，然后在可见时进行网络加载数据：\n\n\n```\n@Override\npublic void setUserVisibleHint(boolean isVisibleToUser) {\n    Log.d(\"TAG\", mTagName + \" setUserVisibleHint() --> isVisibleToUser = \" + isVisibleToUser);\n\n    if (isVisibleToUser) {\n        pullData();\n    }\n    super.setUserVisibleHint(isVisibleToUser);\n}\n```\n\n\n# 三、根据实际用途使用懒加载 #\n\n由第二部分我们可以知道，`setUserVisibleHint(boolean isVisibleToUser)`方法是比`onCreate`更早调用的，但是我们一般在加载数据时，都会在数据加载完成时进行UI更新，所以这就有了一个问题，假如拉取数据是秒回，但是我们还没有进行UI绑定，或者是Adapter初始化等，那么我们就无法更新UI了，所以Fragment给我们提供了另一个方法`getUserVisibleHint()`，它就是用来判断当前Fragment是否可见，所以我们就可以在一系列变量初始化完成后再判断是否可见，若可见再进行数据拉取：\n\n\n```\n@Override\npublic void onStart() {\n    super.onStart();\n    Log.d(\"TAG\", mTagName + \" onStart()\");\n\n    ...\n\n    if(getUserVisibleHint()) {\n        pullData();\n    }\n\n}\n```\n\n当然，如果你的网络请求并不需要涉及UI更新，那么就可以直接在`setUserVisibleHint(boolean isVisibleToUser)`里操作，所以最终还是要根据各自的实际用途来使用。\n\n最后，附上懒加载的Demo：[Github/LazyFragment](https://github.com/ryanlijianchang/LazyFragment)\n\n","tags":["Fragment优化"],"categories":["学习"]},{"title":"AdPlayBanner：功能丰富、一键式使用的图片轮播插件","url":"/2017/07/04/AdPlayBanner：功能丰富、一键式使用的图片轮播插件/","content":"\n# AdPlayBanner #\n\n[AdPlayBanner](https://github.com/ryanlijianchang/AdPlayBanner)是一个Android平台基于ViewPager实现的轮播图插件，主要用以自动或者手动地播放轮播图，提供了Fresco、Picasso、Glide等图片加载方式供用户使用，以及多种图片切换动画，设置轮播时间，设置数据源顺序，提供不同分页指示器等功能，实现了一键式、灵活式的控件使用方式。下面是效果图：\n\n![](http://osjnd854m.bkt.clouddn.com/banner_pic1.gif)\n\n目前AdPlayBanner已经开源到了Github上面，大家可以在Github上面查看本控件的Demo，或者直接使用。\n\nGithub地址为：[https://github.com/ryanlijianchang/AdPlayBanner](https://github.com/ryanlijianchang/AdPlayBanner)\n\n## 一、使用方法 ##\n\n### 1.添加依赖 ###\n\n首先，在项目级别的`build.gradle`文件添加依赖：\n\n    allprojects {\n\t\trepositories {\n\t\t\t...\n\t\t\tmaven { url 'https://jitpack.io' }\n\t\t}\n\t}\n\n然后，在模块目录下的`build.gradle`文件添加依赖：\n\n    dependencies {\n\t\tcompile 'com.github.ryanlijianchang:AdPlayBanner:v0.2'\n\t}\n\n### 2.在布局文件中添加控件 ###\n\n在布局文件中添加AdPlayBanner控件，根据自己的需要设置高度，注意，控件需要在一个布局（可以是LinearLayout，RelativeLayout，FrameLayout等）之内。\n\n    <com.ryane.banner_lib.AdPlayBanner\n        android:id=\"@+id/game_banner\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"200dp\" />\n\n### 3.在Activity中绑定控件 ###\n\t\n\tmAdPlayBanner = (AdPlayBanner) findViewById(R.id.game_banner);\n\n### 4.添加网络权限 ###\n\n由于加载的是网络图片，所以需要在Manifests文件中添加网络请求权限 \n\t\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n\n### 5.初始化Fresco ###\n\n默认使用Fresco加载图片，所以按照Fresco官方做法，需要在Application创建时初始化Fresco，常规做法如下：\n\n(1) 创建MyApplication类继承Application，然后在onCreate()方法中初始化Fresco：\n\n    public class MyApplication extends Application {\n\t    @Override\n\t    public void onCreate() {\n\t        super.onCreate();\n\t        Fresco.initialize(this);\n\t    }\n\t}\n\n(2) 在Manifests文件中<application>标签中增加 `android:name=\"你的类名\"`:\n\n\t<application\n        android:name=\".MyApplication\"\n\t\t...>\n\n\t\t...\n\n    </application>\n\n当然，如果你不使用Fresco加载，以上步骤可以跳过。\n\n### 6.一键式使用 ###\n\t\nAdPlayBanner使用了Builder设计模式，所以可以通过一键式写法来直接装载AdPlayBanner，当然也可以使用常规写法。在使用之前需要先设置数据源，使用ArrayList<AdPageInfo>来封装数据，而AdPageInfo是一个封装好的Bean类，封装如下：\n\n\tpublic class AdPageInfo implements Parcelable {\n\t    public String title;    // 广告标题\n\t    public String picUrl;   // 广告图片url\n\t    public String clickUlr; // 图片点击url\n\t    public int order;       // 顺序\n\t}\n\n在设置完数据源`mDatas`之后，使用Builder模式写法，一句话就可以使用AdPlayBanner了。**注意，`setUp()`方法必须在调用完所有API之后，最后调用**：\n\n\tmAdPlayBanner.setInfoList(mDatas).setUp();\n\n当然，你也可以使用常规写法：\n\n\tmAdPlayBanner.setInfoList(mDatas);\n\tmAdPlayBanner.setUp();\n\n### 7.关闭AdPlayBanner ###\n\n在显示AdPlayBanner的页面生命周期到达onDestroy()时，建议调用`mAdPlayBanner.stop()`方法结束AdPlayBanner，避免内存泄漏。\n\n----------\n\n## 二、功能介绍 ##\n\n### 1.自定义数据顺序 ###\n\n在调用`setUp()`方法之前，我们需要设置数据源，每一页的数据使用`AdPageInfo`来封装，它里面就有一个int型变量`order`,我们通过给每一个`AdPageInfo`赋值order，AdPlayBanner就会**自动**按照order的大小来排序，如：\n\n我们封装了三个数据到ArrayList里面，按顺序是图片1->图片2->图片3\n\n\tList<AdPageInfo> mDatas = new ArrayList<>();\n\tAdPageInfo info1 = new AdPageInfo(\"图片1\", \"http://osjnd854m.bkt.clouddn.com/pic1_meitu_1.jpg\", \"链接1\", 3);\n    AdPageInfo info2 = new AdPageInfo(\"图片2\", \"http://osjnd854m.bkt.clouddn.com/pic1_meitu_2.jpg\", \"链接2\", 2);\n    AdPageInfo info3 = new AdPageInfo(\"图片3\", \"http://osjnd854m.bkt.clouddn.com/pic1_meitu_3.jpg\", \"链接3\", 1);\n    mDatas.add(info1);\n    mDatas.add(info2);\n    mDatas.add(info3);\n\n装载之后运行，可见轮播顺序是按照order的顺序来播放：\n\n![](http://osjnd854m.bkt.clouddn.com/order.gif)\n\n### 2.无限循环轮播 ###\n\n很多轮播插件没有实现无限循环轮播这个功能, 而在AdPlayBanner上得到了实现，如下图可见，当我们无限循环滑动时，插件仍能正常运行：\n\n![](http://osjnd854m.bkt.clouddn.com/pic_circle_play_new.gif)\n\n### 3.支持三种图片加载方式 ###\n\n目前比较主流的Fresco、Picasso、Glide三种图片加载方式在AdPlayBanner中都支持，至于三者的区别我就不赘述了，默认是使用Fresco方式加载，具体调用方法`setImageLoadType(ImageLoaderType type)`，只需要将传入数据设置为：`FRESCO`、`GLIDE`、`PICASSO`其中一种即可，同样，也是可以通过代码一键式使用，例如使用Glide方式加载（其他加载方式使用类似），使用方法如下：\n\n    mAdPlayBanner\n            .setInfoList((ArrayList<AdPageInfo>) mDatas)\n            .setImageLoadType(Glide)\t// 设置Glide类型的图片加载方式\n            .setUp();\n\n### 4.支持多种ScaleType ###\n\n在AdPlayBanner中，可以根据用户需要设置图片的ScaleType，具体效果和ImageView的ScaleType一致，默认是使用`FIT_XY`，但是在AdPlayBanner中比ImageView少了一种`MATRIX`类型，在AdPlayBanner中具体支持的ScaleType有如下：`FIT_XY`、`FIT_START`、`FIT_CENTER`、`FIT_END`、`CENTER`、`CENTER_CROP`、`CENTER_INSIDE`其中，具体调用方法`setImageViewScaleType(ScaleType scaleType)`，只需要将具体的ScaleType传入即可，同样，也是可以通过代码一键式使用，例如设置ScaleType为`FIT_START`（其他类似），使用方法如下：\n\n    mAdPlayBanner\n            .setInfoList((ArrayList<AdPageInfo>) mDatas)\n            .setImageViewScaleType(FIT_START)\t// 设置FIT_START类型的ScaleType\n            .setUp();\n\n### 5.支持不同页码指示器 ###\n\n在AdPlayBanner中，提供了`数字型`、`点型`和`空型`页码指示器，用户可以通过调用`setIndicatorType(IndicatorType type)`，传入`NONE_INDICATOR`，`NUMBER_INDICATOR`，`POINT_INDICATOR`其中一种，即可显示对应的页码指示器，三种页码指示器对应效果如下：\n\n(1) `NONE_INDICATOR`：空型页码指示器\n\n![](http://osjnd854m.bkt.clouddn.com/indicator_none.jpg)\n\n(2) `NUMBER_INDICATOR`：数字页码指示器\n\n![](http://osjnd854m.bkt.clouddn.com/indicator_number.jpg)\n\n(3) `POINT_INDICATOR`：点型页码指示器\n\n![](http://osjnd854m.bkt.clouddn.com/indicator_point.jpg)\n\n使用方法也是非常简单，如我需要使用数字型页码指示器，使用方法如下：\n\n    mAdPlayBanner\n            .setInfoList((ArrayList<AdPageInfo>) mDatas)\n            .setIndicatorType(NUMBER_INDICATOR)\t\t//使用数字页码指示器\n            .setUp();\n\n此外，你也可以调用`setNumberViewColor(int normalColor, int selectedColor, int numberColor)`来修改数字型页码指示器的样式，`normalColor`为数字没选中时的背景颜色，`selectedColor`为数字选中时的背景颜色，`numberColor`为数字的字体颜色，例如我通过调用这个方法，把三个颜色都改变掉（注意：传入int型颜色必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效），使用方法如下：\n\n    mAdPlayBanner\n            .setInfoList((ArrayList<AdPageInfo>) mDatas)\n            .setIndicatorType(NUMBER_INDICATOR)     //使用数字页码指示器\n            .setNumberViewColor(0xff00ffff, 0xffff3333, 0xff0000ff)\n            .setUp();\n\n得到如下效果：\n\n![](http://osjnd854m.bkt.clouddn.com/numberview_color.jpg)\n\n### 6.添加灵活性标题 ###\n\n在AdPlayBanner中，只需要调用`addTitleView(TitleView mTitleView)`，就可以插入标题了，并且该标题的灵活性很强，可以根据用户需要修改标题的背景、位置、字体大小、padding、magin等，先上一个提供的默认效果：\n\n![](http://osjnd854m.bkt.clouddn.com/pic_title_view_little.gif)\n\n由于是使用了默认的效果，所以用法也是非常简单：\n\n    mAdPlayBanner\n            .setInfoList((ArrayList<AdPageInfo>) mDatas)\n            .setIndicatorType(POINT_INDICATOR)     //使用数字页码指示器\n            .addTitleView(TitleView.getDefaultTitleView(getApplicationContext()))  // 使用默认标题\n            .setUp();\n\n我们可以看到我们通过调用`addTitleView(TitleView mTitleView)`，传入一个TitleView即可以生成标题，而上面是调用了AdPlayBanner提供的一个默认标题，当然，我们也说了这个标题的灵活性很强，就是我们可以设置TitleView的属性，我们来看一下TitleView提供了哪些API：\n\n- `TitleView setTitleColor(int color)`：设置标题字体颜色，传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效。\n- `setPosition(Gravity gravity)`：设置标题在AdPlayBanner中的位置，有`PARENT_TOP`,`PARENT_BOTTOM`,`PARENT_CENTER`三个取值，分别位于父布局顶部，父布局底部，父布局中间。\n- `setViewBackground(int color)`：设置标题的背景颜色，传入int型颜色必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效。\n- `TitleView setTitleSize(int size)`：设置标题的字体大小，单位是sp。\n- `setTitleMargin(int left, int top, int right, int bottom)`：设置标题的四个方向margin值，单位是dp。\n- `setTitlePadding(int left, int top, int right, int bottom)`：设置标题的四个方向padding值，单位是dp。\n\n同样，TitleView也是支持Builder模式的写法，例如我自定义一个TitleVIew并加到AdPlayBanner中，使用方法如下：\n\n    mAdPlayBanner\n            .setInfoList((ArrayList<AdPageInfo>) mDatas)\n            .setIndicatorType(POINT_INDICATOR)     // 使用数字页码指示器\n            .addTitleView(new TitleView(getApplicationContext())    // 创建新的TitleView\n                                .setPosition(PARENT_TOP)\n                                .setTitleColor(0xffffffff)          // 设置字体颜色\n                                .setViewBackground(0x9944ff18)      // 设置标题背景颜色\n                                .setTitleSize(18)                   // 设置字体大小\n                                .setTitleMargin(0,0,2,0)           // 设置margin值\n                                .setTitlePadding(2,2,2,2))          // 设置padding值\n            .setUp();\n\n效果如下：\n\n![](http://osjnd854m.bkt.clouddn.com/pic_title_view_zidingyi%20.gif)\n\n\n### 7.支持多样式切换动画 ###\n\n由于AdPlayBanner是基于ViewPager实现的，所以AdPlayBanner和ViewPager一样，同样支持自定义的切换动画，只需要通过调用`setPageTransfromer(ViewPager.PageTransformer transformer)`方法，传入一个PageTransformer，即可改变它的切换样式，AdPlayBanner中提供了三种现成的切换方式：\n\n- `FadeInFadeOutTransformer`：淡入淡出效果\n\n![](http://osjnd854m.bkt.clouddn.com/fade_in.gif)\n\n- `RotateDownTransformer`：旋转效果\n\n![](http://osjnd854m.bkt.clouddn.com/rotate.gif)\n\n- `ZoomOutPageTransformer`： 空间切换效果\n\n![](http://osjnd854m.bkt.clouddn.com/zoom_out.gif)\n\n使用起来也是非常简单，例如使用ZoomOutPageTransformer切换效果：\n\n    mAdPlayBanner\n            .setInfoList((ArrayList<AdPageInfo>) mDatas)\n            .setIndicatorType(POINT_INDICATOR)     // 使用数字页码指示器\n            .setBannerBackground(0xff000000)       // 设置背景颜色\n            .setPageTransfromer(new ZoomOutPageTransformer())   // 设置切换效果\n            .setUp();\n\n当然，你也可以自定义一个transformer实现ViewPager.PageTransformer接口，并重写`transformPage(View view, float position)`方法即可实现自定义的切换效果。\n\n### 8.设置是否自动轮播 ###\n\n通过调用`setAutoPlay(boolean autoPlay)`,传入boolean值控制是否自动播放的开关，传入true为自动，传入false为手动。\n\n### 9.设置自动滑动间隔时间 ###\n\n通过调用`setInterval(int interval)`，传入int型的时间（单位ms），即可改变AdPlayBanner自动轮播时的切换时间。\n\n### 10.设置点击事件监听器 ###\n\nAdPlayBanner支持点击事件监听，通过调用`setOnPageClickListener(OnPageClickListener l) `，传入OnPageClickListener，即可完成AdPlayBanner的点击监听，使用方法非常简单：\n\n    mAdPlayBanner\n        .setInfoList((ArrayList<AdPageInfo>) mDatas)\n        .setIndicatorType(POINT_INDICATOR)     // 使用数字页码指示器\n        .setOnPageClickListener(new AdPlayBanner.OnPageClickListener() {\n            @Override\n            public void onPageClick(AdPageInfo info, int postion) {\n                // 点击操作\n            }\n        })\n        .setUp();\n\n### 11.关闭AdPlayBanner ###\n\n在离开显示AdPlayBanner的页面时，建议调用`stop()`方法，避免内存泄漏。\n\n## 三、API ##\n\n**AdPlayBanner：实现轮播效果的控件**\n\nAdPlayBanner | 解释 | 备注\n----|------|----\naddTitleView(TitleView mTitleView) | 添加一个TitleView  | 可以通过TitleView.getDefaultTitleView(Context context)来使用默认的TitleView或者通过new Title()的方式传入\nsetBannerBackground(int color) | 设置AdPlayBanner的背景颜色  | 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效\nsetIndicatorType(IndicatorType type) | 设置页码指示器类型  | 传入`NONE_INDICATOR`，`NUMBER_INDICATOR`，`POINT_INDICATOR`其中一种\nsetInterval(int interval) | 设置自动轮播时的切换时间 | 单位ms\nsetImageLoadType(ImageLoaderType type) | 设置图片加载方式 | 传入`FRESCO`、`GLIDE`、`PICASSO`其中一种\nsetPageTransfromer(ViewPager.PageTransformer transformer) | 设置切换动画，如果不设置动画，设置为null | 提供了`FadeInFadeOutTransformer`，`RotateDownTransformer`，`ZoomOutPageTransformer`三种，也可以传入自定义的TransFormer\nsetNumberViewColor(int normalColor, int selectedColor, int numberColor) | 设置数字页码的颜色 | normalColor   数字正常背景颜色，selectedColor 数字选中背景颜色，numberColor   数字字体颜色\nsetOnPageClickListener(OnPageClickListener l) | 设置事件点击监听器 | 传入一个OnPageClickListener\nsetImageViewScaleType(ScaleType scaleType) | 设置图片的ScaleType | 传入`FIT_XY`、`FIT_START`、`FIT_CENTER`、`FIT_END`、`CENTER`、`CENTER_CROP`、`CENTER_INSIDE`其中一种\nsetAutoPlay(boolean autoPlay) | 设置是否自动播放 | 默认为true 自动播放，传入false为手动\nsetInfoList(ArrayList<AdPageInfo> pageInfos) | 设置Banner的数据源 | 传入必须为AdPageInfo类型的ArrayList\nsetUp() | 装载AdPlayBanner | 必须在以上所有方法调用完之后才能调用\nstop()  | 结束AdPlayBanner | 在离开显示AdPlayBanner页面时调用，避免内存泄漏\n\n**TitleView ： 标题控件**\n\nTitleView | 解释 | 备注\n----|------|----\ngetDefaultTitleView(Context context) | 获取一个默认的TitleView | 传入一个Context\nsetTitleSize(int size) | 设置字体大小 | 单位sp\nsetTitleColor(int color) | 设置字体颜色 | 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效\nsetViewBackground(int color) | 设置标题背景 | 传入color必须ARGB8888的颜色类型，或者通过资源文件定义颜色再获取才有效\nsetPosition(Gravity gravity) | 设置标题在Banner的位置 | 只能`PARENT_TOP`,`PARENT_BOTTOM`,`PARENT_CENTER`其中一个值\nsetTitleMargin(int left, int top, int right, int bottom) | 设置标题的margin值 | 单位dp\nsetTitlePadding(int left, int top, int right, int bottom) | 设置标题的padding值 | 单位dp\n\n**AdPageInfo：AdPlayView指定的数据源**\n\nAdPageInfo | 解释 | 备注\n----|------|----\nAdPageInfo(String title, String picUrl, String clickUlr, int order) | 构造方法 | \nvoid setTitle(String title) | 设置标题 | \nString getTitle() | 获取标题 |\nvoid setPicUrl(String picUrl) | 设置图片源地址 | \nString getPicUrl() | 获取图片链接 |\nvoid setClickUlr(String clickUlr) | 设置点击事件地址 | \nString getClickUlr() | 获取点击事件链接 |\nvoid setOrder(int order) | 设置排序的优先级 | 设置了order，AdPlayBanner会根据order的大小由小到大排序\nint getOrder() | 获取排序优先级 |\n\n## 四、版本特性 ##\n\n### v0.1 ###\n\n1. 基本框架搭建完成；\n\n### V0.2 ###\n\n1. 支持定义数据顺序；\n2. 无限循环轮播；\n3. 支持Fresco、Glide、Picasso三种图片加载方式；\n4. 支持多种ScaleType；\n5. 支持点型、数字型、空型页码指示器；支持修改数字型页码器的样式；\n6. 支持灵活性标题；支持修改标题的位置、字体大小、颜色、边距值等属性；\n7. 支持多样式切换动画；\n8. 支持设置自动轮播开关；\n9. 自定义自动滑动间隔时间；\n10. 提供点击事件监听器；\n11. 支持修改AdPlayBanner的背景颜色；\n\n### V0.3 ###\n\n1. 修复了静态变量造成的内存泄漏问题;\n2. 提供手动结束Banner播放的接口;\n\n## 五、 Demo ##\n\n如果大家在使用在仍然有问题，可以通过下载[Demo](https://github.com/ryanlijianchang/AdPlayBanner)来学习，当然，大家更可以通过查看源代码来学习如何自定义一个轮播控件。\n\n## 六、后记 ##\n\nAdPlayBanner作为作者的第一个开源控件，作者也是非常用心认真地完成，这个过程也学习到很多东西，可能其中会遇到很多错误，所以希望大家可以多多包涵，然后把错误提到Issues里面，作者会在看到的第一时间进行修正。在后面的时间里，作者也会将更多的特性加到这个控件里面，所以希望大家可以加个star，以作为对作者的小小鼓励。 当然，如果你想第一时间联系到作者，不妨尝试以下联系方式：\n\n\n- Email：liji.anchang@163.com \n- CSDN：[http://blog.csdn.net/ljcitworld](http://blog.csdn.net/ljcitworld)\n- Github：[https://github.com/ryanlijianchang](https://github.com/ryanlijianchang)\n\n\n\n\n\n\n\n\n","tags":["图片轮播"],"categories":["学习"]},{"title":"Android基础夯实--重温动画（五）之属性动画 ObjectAnimator详解","url":"/2017/04/25/Android基础夯实--重温动画（五）之属性动画 ObjectAnimator详解/","content":"\n*只有一种真正的英雄主义*\n\n\n# 一、摘要 #\n\nObjectAnimator是ValueAnimator的子类，它和ValueAnimator一样，同样具有计算属性值的功能，但对比ValueAnimator，它会更加容易使用，因为它不再需要设置监听器来监听值的变化，因为这个工程对于ObjectAnimator来说，是自动的。这篇文章主要通过详细讲解ObejctAniamtior，加深大家对属性动画的认识，让我们对于动画的技巧掌握得更扎实。\n\n如果你想了解更权威的解释，可以查看官方文档：[Property Animation](https://developer.android.com/guide/topics/graphics/prop-animation.html#property-vs-view)。\n\n本文主要对ValueAnimator做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。\n\n# 二、 概述 #\n\n在上节我们知道了在属性动画中，ValueAnimator是通过监听值的变化，然后实现控件的动画播放。在代码过程中，是通过设置初始值、结束值和动画时间，然后通过加速器返回当前的进度的，再经过Evaluator根据进度计算出具体的值，然后我们在监听器里面不断监听拿到这个值，然后修改控件的属性值，从而实现动画。\n\nObjectAnimator作为ValueAnimator的子类，所以ValueAnimator的很多方法，在ObjectAnimator中也能使用，但是ObjectAnimator覆写了父类的几个方法，如ofInt()，ofFloat()，ofArgb()等。它和ValueAnimator同样也是首先设置初始值、结束值和动画时长，但是同时也绑定了目标控件和属性然后通过加速器返回当前的进度的，再经过Evaluator根据进度计算出具体的值，最后根据属性拼接set函数并反射调用，并将当前值作为参数传入，实现动画。\n\n对比这两个Animator，ObjectAnimator是对ValueAnimator的再封装，它的封装帮助我们避免了使用Listener的麻烦，更加精简了代码，使开发者可以更加专注动画的逻辑代码。\n\n## 2.1 差异 ##\n\n以下通过Demo来对比ObjectAnimator和ValueAnimator的区别，我们同样使用ObjectAnimator和ValueAnimator实现同样的效果，控件水平方向上的不断左右移动，最后返回原点（如下图）。\n\n![Demo](http://7xrwkh.com1.z0.glb.clouddn.com/saa.gif)\n\n通过上一节的学习，我们可以轻松写出ValueAnimator实现的代码：\n\n\n```\nValueAnimator animator = ValueAnimator.ofFloat(0, 300, -100, 200, -50, 0);\nanimator.setDuration(2000);\nanimator.start();\nanimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation) {\n        mBinding.image.setTranslationX((Float) animation.getAnimatedValue());\n    }\n});\n```\n\n在ObjectAnimator中，我们可以用更简单的代码来实现：\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"translationX\", 0, 300, -100, 200, -50, 0);\nanimator.setDuration(2000);\nanimator.start();\n```\n\n通过对比，我们可以看到，ObjectAnimator在实现动画上的代码上会更加简洁，但是实现的效果都是一样的，之所以是这样，是因为ObjectAnimator覆写了ValueAnimator 的ofFloat方法，并对其进行了封装。所以，我们看到ObjectAnimator实现代码上都减少了Listener代码的编写。\n\n大家第一次看到ObjectAnimator可能看到代码比较陌生，上面的一段代码什么意思呢？首先我们看到第一个参数，就是我们动画的目标控件，也就是这个动画要让哪个控件来实现，我这里是DATABinding的一个写法，其实就是我们findViewById得到的一个view，非常的简单；第二个参数是动画要实现的效果，我这里是translationX，即水平x方向上的位移；第三个参数为可变参数，即动画变化过程的系列值，跟ValueAnimator是一样的意思。\n\n![参数](http://7xrwkh.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720170327113616.png)\n\n## 2.2 propertyName ##\n\n在2.1的介绍过后，大家可能还会有疑问，对于上面ofFloat的第二个参数是一个字符串常量，这个字符串常量我们是怎么获取的呢？其实，在ObejctAnimator中，无论ofFloat，ofInt，ofArgb等方法，都有一个叫做propertyName的参数，也就是我们上面对应的第二个参数，这个参数是一个字符串，之所以动画会实现该字符串的效果是因为ObjectAnimator通过反射机制，找到了ImageView中的setTranslationX()这个方法，然后每个十几ms就调用这个方法，并把我们的变化的值传到里面去，从而实现动画效果。\n\n所以到这里大家可以知道，当我们需要用ObjectAnimator实现一个控件的动画效果时，我们首先需要做的就是在这个控件中找到对应的setXXX()驼峰式写法的方法，只有控件拥有相应的setXXX()方法， 我们传入的propertyName参数才起到作用。那么这时候就有同学会问，类似Demo中的“translationX”，它对应的方法是setTranslationX()，那我们应该传入“TranslationX”还是“translationX”，其实都是可以的，因为它内部封装在使用反射机制调用方法时，涵盖了两种写法，所以第一个字母可以大小写，但是后面的字母必须全部对应大小写。\n\n其次还要同学会疑问，我们怎么知道在实例化ObjectAnimator时应该通过ofFloat还是ofInt还是其他呢？其实跟我们的ValueAnimator一样，我们调用哪个方法来实例化都是要考虑我们要改变的控件哪个属性的。例如，我们上面的例子是改变水平方向上的位移，那么ObjectAnimator最终是调用控件的setTranslationX(float translationX)，我们可以看到传入参数是float型，那么毫无疑问，我们这里需要使用ofFloat了，其它以此类推。下面给大家举例一些常用的propertyName。\n\n### 2.2.1 Scale ###\n\nView中关于伸缩变化(Scale)有以下两个方法：\n- public void setScaleX(float scaleX)：X方向上伸缩。\n- public void setScaleY(float scaleY)：Y方向上伸缩。\n\n![Scale](http://7xrwkh.com1.z0.glb.clouddn.com/mscale.gif)\n\n所以对应代码为：\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"scaleX\", 0f, 1.5f, 2f, 1.5f, 0f, 0.5f, 0.2f, 1f);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.setDuration(2000);\nanimator.start();\n```\n\n\n```\nView view = new View(MyObjectAnimator.this);\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"scaleY\", 0f, 1.5f, 2f, 1.5f, 0f, 0.5f, 0.2f, 1f);\nanimator.setDuration(2000);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.start();\n```\n\n### 2.2.2 Translation ###\n\nView中关于位置变化(Translation)有以下两个方法：\n- public void setTranslationX(float translationX)：X轴上位移。\n- public void setTranslationY(float translationY)：Y轴上位移。\n- public void setTranslationZ(float translationZ)：设置阴影。\n\n![Translation](http://7xrwkh.com1.z0.glb.clouddn.com/translation.gif)\n\n所以对应代码为：\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"translationX\", 0, 100, -100, 0);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.setDuration(2000);\nanimator.start();\n```\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"translationY\", 0, 100, -100, 0);\nanimator.setDuration(2000);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.start();\n```\n\n### 2.2.3 Alpha ###\n\nView中关于透明度变化(Alpha)有以下方法：\n- public void setAlpha(float alpha);\n\n![Alpha](http://7xrwkh.com1.z0.glb.clouddn.com/alpha.gif)\n\n所以对应代码为：\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"alpha\", 0, 0.5f, 1.0f);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.setDuration(2000);\nanimator.start();\n```\n\n### 2.2.4 Rotation ###\n\nView中关于角度变化(Rotation)有以下方法：\n- public void setRotation(float rotation)：关于Z轴旋转。\n- public void setRotationX(float rotationX)：关于X轴旋转。\n- public void setRotationY(float rotationY)：关于Y轴旋转。\n\n![Rotation](http://7xrwkh.com1.z0.glb.clouddn.com/saaaass.gif)\n\n所以对应代码为：\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"rotation\", 0, 180, 0, -180, 0);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.setDuration(3000);\nanimator.start();\n```\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"rotationX\", 0, 180, 0, -180, 0);\nanimator.setDuration(3000);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.start();\n```\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"rotationY\", 0, 180, 0, -180, 0);\nanimator.setDuration(3000);\nmBinding.image.setScaleType(ImageView.ScaleType.CENTER_CROP);\nanimator.start();\n```\n\n### 2.2.5 图片变化 ###\n\nView中关于图片的其中一个方法是setBackgroundResource，同样我们也可以通过ObjectAnimator来实现一个图片变化的效果：\n- public void setBackgroundResource(@DrawableRes int resid)\n\n![图片变化](http://7xrwkh.com1.z0.glb.clouddn.com/gggg.gif)\n\n对应代码为：\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofInt(mBinding.image, \"backgroundResource\", R.drawable.a1, R.drawable.a2, R.drawable.a3);\nanimator.setDuration(2000);\nanimator.start();\n```\n\n其实还有很多set方法可以可以实现动画效果，这里就不再一一列举，大家有兴趣可以自己去深入研究，你会发现ObjectAnimator可以非常简单快捷地实现动画效果。\n\n\n## 2.3 实例化ObjectAnimator方法 ##\n\n在ValueAnimator中，我们知道实例化并不是通过new一个对象出来，而是通过ofInt，ofFloat，ofObject等方法。在ObjectAnimator中同样如此，因为ofInt，ofFloat，ofObject等方法的内部帮我们封装了实例化过程，所以我们可以直接调用来拿到一个实例化的对象。在ObjectAnimator中，大概有以下几种实例化方法：\n\n\n### 2.3.1 ofInt() ###\n\n通过ofInt()来实例化对象，那么属性值必须为int型，通常我们通过ofInt可以实现很多动画，例如实现颜色渐变等；ofInt()也有几个重载函数，这里介绍其中一个：\n\n- ofInt(Object target, String propertyName, int... values)：对目标对象T的property属性值进行改变。\n\n例如颜色值的变化。\n\n![ofInt](http://7xrwkh.com1.z0.glb.clouddn.com/color.gif)\n\n\n```\nObjectAnimator animator = ObjectAnimator.ofInt(mBinding.image, \"backgroundColor\",  0xffff00ff, 0xffffff00, 0xffff00ff);\nanimator.setEvaluator(new ArgbEvaluator());\nanimator.setDuration(4000);\nanimator.start();\n```\n\n### 2.3.2 ofFloat() ###\n\nofFloat()来实例化对象，那么属性值必须为float型，通常我们通过ofFloat可以实现很多动画，例如实现位置变化等；ofFloat()也有几个重载函数，这里介绍其中一个：\n\n- ObjectAnimator ofFloat (Object target, String xPropertyName, String yPropertyName, Path path)：：对目标对象T的property属性值进行改变。\n\n例如实现一个贝塞尔曲线：\n\n![ofFloat](http://7xrwkh.com1.z0.glb.clouddn.com/path.gif)\n\n\n```\nPath path = new Path();\npath.quadTo(800, 200, 800, 800);\nObjectAnimator animator = ObjectAnimator.ofFloat(mBinding.image, \"x\", \"y\", path);\nanimator.setDuration(4000);\nanimator.start();\n```\n\n### 2.3.3 ofArgb() ###\n\n我们在ValueAnimator中已经提到了ofArgb()可以帮助我们实现颜色的渐变效果，这里同样是可以通过ofArgb()来实现动画效果。上面我们已经在ofInt里面实现了颜色渐变，但是代码稍多，所以Google在API LEVEL 21之后增加了这个方法ofArgb()。通过这个方法我们更容易地实现颜色演变，因为它里面封装了对ArgbEvaluator的使用，实现2.3.1的效果，大家可以对比一下代码：\n\n![ofInt](http://7xrwkh.com1.z0.glb.clouddn.com/color.gif)\n\n```\nObjectAnimator animator = ObjectAnimator.ofArgb(mBinding.image, \"BackgroundColor\", 0xffff00ff, 0xffffff00, 0xffff00ff);\nanimator.setDuration(4000);\nanimator.start();\n```\n\n### 2.3.4 ofPropertyValuesHolder() ###\n\n认真的同学都会发现，在ValueAnimator和ObjectAnimator中，都有一个实例化方法，就是ofPropertyValuesHolder()方法，由于在ObjectAnimator中使用更为广泛，所以这里以ObjectAnimator的ofPropertyValuesHolder为例子，当大家懂了之后，那么大家对ValueAnimator的ofPropertyValuesHolder也应该理解了。\n\n在ObjectAnimator中，我们可以通过\n\n- ObjectAnimator ofPropertyValuesHolder (Object target, \n                PropertyValuesHolder... values)\n\n来实例化一个ObjectAnimator。\n\n我们可以看到，它和我们其他的实例化方法差不多，都需要设置一个target（目标控件），还有一组PropertyValuesHolder类型的值，但是不需要设置属性，target我们知道了，是要实现动画的控件，那么PropertyValuesHolder是什么呢？我们来看一下官方文档：\n\n> This class holds information about a property and the values that that property should take on during an animation. PropertyValuesHolder objects can be used to create animations with ValueAnimator or ObjectAnimator that operate on several different properties in parallel.\n\n什么意思呢？\n\n> 这是一个包含一个属性信息的类，并且它的值应该用到一个动画里面。PropertyValuesHolder对象可以配合ValueAnimator和ObjectAnimator来实现不同属性的并行的动画。\n\n听起来有点别扭，也就是说，当我们需要实现一个包含多种属性的同时播放的动画时，我们就可以使用ofPropertyValuesHolder来实例化一个Animator，当然，拥有一个属性时也是可以的，为什么这么说？ofFloat()的内部实现其实就是将传进来的参数封装成PropertyValuesHolder实例来保存动画状态。所以可见PropertyValuesHolder是多么有用了吧。\n\n在PropertyValuesHolder这个类里面，同样也有ofInt()，ofFloat()，ofKeyframe()等方法来实例化，举个例子：\n\n![PropertyValuesHolder](http://7xs0af.com1.z0.glb.clouddn.com/property.gif)\n\n代码也非常简单：\n\n\n```\nPropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(\"Rotation\", 90, -90, 45, -45, 60, -60);\nPropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt(\"BackgroundColor\", 0xff55aa11, 0xff115633, 0xff123344, 0xffaabbcc);\nPropertyValuesHolder scaleXHolder = PropertyValuesHolder.ofFloat(\"ScaleX\", 1f, 1.1f, 1.2f, 1.5f, 1.8f, 1.5f, 1.2f, 1.1f, 1);\nPropertyValuesHolder scaleYHolder = PropertyValuesHolder.ofFloat(\"ScaleY\", 1f, 1.1f, 1.2f, 1.5f, 1.8f, 1.5f, 1.2f, 1.1f, 1);\nObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mBinding.image, rotationHolder, colorHolder, scaleXHolder, scaleYHolder);\nanimator.setDuration(3500);\nanimator.setInterpolator(new AccelerateInterpolator());\nanimator.start();\n```\n\n通过代码我们可以知道，通过ofPropertyValuesHolder来实例化，其实就是将不同动画效果分配到一个个PropertyValuesHolder中去，然后把多个不同的PropertyValuesHolder对象在初始化时传入，最终实现多个效果并行播放。\n\n\n\n\n### 2.3.4 其他实例化方法 ###\n\n在ObjectAnimator中提供了非常丰富的实例化方法，除了以上三个之外，在API LEVEL 21之后，Google推出了更多的实例化方法，例如：\n\n- ofMultiFloat()\n- ofMultiInt()\n- ofObject()\n- ofPropertyValuesHolder()\n\n在上面三个(2.3.1-2.3.3)不足以解决我们需求的时候，我们可以到官方文档参考这三个比较新的实例化方法，它们也是为了简化操作而进行了更高度的封装，所以这也有助于帮助我们用更少的代码来实现动画。\n\n\n# 总结 #\n\nObjectAnimator作为ValueAnimator的子类，在代码上对ValueAnimator进行了进一步的封装，使我们在日常使用中更加简单，但是正是因为封装，使得我们在一些特殊情况下使用ObjectAnimator使用上还是有一定的局限性，所以在大家掌握了ValueAnimator和ObjectAnimator的基本使用后，还需要自己通过写小Demo来加深和进阶使用，这样在我们用到时方能得心应手。\n","tags":["动画"],"categories":["学习"]},{"title":"Android基础夯实--重温动画（四）之属性动画 ValueAnimator详解","url":"/2017/04/10/Android基础夯实--重温动画（四）之属性动画 ValueAnimator详解/","content":"\n*宝剑锋从磨砺出,梅花香自苦寒来；千淘万漉虽辛苦,吹尽狂沙始到金； 长风破浪会有时,直挂云帆济沧海*\n\n# 一、摘要 #\nAnimator类作为属性动画的基类，它是一个抽象类，它提供了实现动画的基本架构，但是我们不能直接使用它，因为它只是提供了最基本的的实现动画的方法，只有让它的子类继承它并进行相应扩展之后，我们才会使用它实现动画。在属性动画中，Animator包括了ValueAnimator、ObjectAnimator和AnimatorSet三个子类，下面给大家详解ValueAnimator。\n\n如果你想了解更权威的解释，可以查看官方文档：[Property Animation](https://developer.android.com/guide/topics/graphics/prop-animation.html#property-vs-view)。\n\n本文主要对ValueAnimator做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。\n\n# 二、ValueAnimator #\n\nValueAnimator，就是针对值的，也就是说ValueAnimator不会对控件进行任何操作，而是控制值的变化，然后我们监听这个值的变化过程，自己来控制控件的变化。什么意思呢？就像我们上面1.2中的例子，使用属性动画来控制TextView的位移，我们在初始化ValueAnimator时，会设置一个初始值和结束的值，例子我用这两个值来控制TextView在y轴上的位置，然后设置监听器，监听初始值变化到结束值的过程，在不断变化过程中，通过调用TextView的layout方法来不断更新TextView的位置，从而实现位移动画。\n\n## 2.1 初识ValueAnimator ##\n\n先上一个例子，实现图片的渐变过程：\n\n![Alpha](http://7xs0af.com1.z0.glb.clouddn.com/ezgif.com-video-to-gif%20%288%29.gif)\n\n我们都知道，在使用Tween Animation时是非常容易实现的，使用AlphaAnimation就可以实现，假如我们用属性动画的话，怎么实现呢？也是非常简单，布局代码就不贴了，看看使用ValueAnimator如何简单快捷地实现渐变动画。\n\n\n```\n// 第一步，创建一个ValueAnimator。直接调用ValueAnimator.ofFloat来初始化，设置开始值和结束值\nfinal ValueAnimator alphaAnimator = ValueAnimator.ofFloat(1, 0);\n// 设置变化时长\nalphaAnimator.setDuration(1000);\nalphaAnimator.start();\n\n// 第二步，ValueAnimator设置监听器\nalphaAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation) {\n        // 我们来检查一下这个方法会调用多少次\n        Log.i(\"TAG\", \"curValue is \" + animation.getAnimatedValue());\n        // 在ValueAnimator变化的过程中更新控件的透明度\n        mBinding.image.setAlpha((float)alphaAnimator.getAnimatedValue());\n    }\n});\n```\n\n而我们在监听器内设置的Log的结果如下，我们可以看到onAnimationUpdate方法被不断地执行，输出值不断由我们设置的初始值变化到我们设置的结束值，所以这个值的变化过程正是我们需要让控件变化的过程。\n\n![Log结果](http://7xs0af.com1.z0.glb.clouddn.com/1490325926%281%29.jpg)\n\n通过例子，我们可以大概总结使用ValueAnimator的两个主要过程：\n\n**(1). 初始化ValueAnimator，并设置初始值和结束值，还有动画的时间，然后start。**\n\n**(2). 给ValueAnimator设置监听器，通过getAnimatedValue()拿到变化值，然后我们手动更新控件的变化。**\n\n## 2.2 深入了解ValueAnimator ##\n\n由于ValueAnimator里面的方法确实不少，所以我们从上面的例子入手，从常用到不常用地讲解ValueAnimator的API，毕竟只要我们掌握了最常用的知识点之后，在我们需要时再去深入了解不常用的知识点，我觉得是个最有效率的学习方式。\n\n由上面的Demo代码的第一步我们可以看到，首先我们需要获取到一个ValueAnimator实例，按照我们的常规思维，我们都会通过new一个对象出来，以代码为例，我们是通过ofFloat方法来获取一个实例对象，那么我们的第一个疑问就是关于构造函数的，到底ValueAnimator有没有构造函数呢？如果有，为什么不通过构造函数来初始化呢？\n\n答案是有的，至于为什么，我们一探究竟。\n\n### 2.2.1构造函数 ####\n\n- **ValueAnimator()**：创建一个ValueAnimator对象。\n\nValueAnimator确实有它的构造函数，但是官方文档不建议我们直接使用它，因为在内部实现的时候才会用到它。之所以不需要用到它，是因为API给我们封装了一系列的的方法来获取实例对象。\n\n\n### 2.2.2实例化对象的方法 ###\n\n- **ValueAnimator ofInt (int... values)**：返回一个int型变化的ValueAnimator。\n- **ValueAnimator ofFloat (float... values)**：返回一个float型变化的ValueAnimator。\n- **ValueAnimator ofObject (TypeEvaluator evaluator, Object... values)**：返回一个object型变化的ValueAnimator。\n- **ValueAnimator ofArgb (int... values)**：返回一个颜色值变化的ValueAnimator，API LEVEL 21引入。\n- **ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values)**：返回一个PropertyValuesHolder型变化的ValueAnimator，在ObjectAnimator再详说。\n\n为什么我们需要通过这些方法来实例化对象呢？这是因为这些方法内部都对实例化对象进行了封装，我们以ofInt为例看一下它的内部实现，它内部其实还是通过new的方式来实例化，然后通过设置一些属性，然后返回这个ValueAnimator对象。\n\n```\npublic static ValueAnimator ofInt(int... values) {\n    ValueAnimator anim = new ValueAnimator();\n    anim.setIntValues(values);\n    return anim;\n}\n```\n\n#### ofArgb的使用 ####\n\n在ValueAnimator中的ofArgb()可以帮助我们实现颜色的渐变效果，Google在API LEVEL 21之后增加了这个方法ofArgb()。通过这个方法我们更容易地实现颜色演变，通过ofArgb和ArgbEvaluator，我们可以轻松实现颜色渐变效果：\n\n![ofInt](http://7xrwkh.com1.z0.glb.clouddn.com/color.gif)\n\n代码：\n\n\n```\nValueAnimator animator = ValueAnimator.ofInt(0xffff00ff, 0xffffff00, 0xffff00ff);\nanimator.setEvaluator(new ArgbEvaluator());\nanimator.setDuration(3000);\nanimator.start();\nanimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation) {\n        mBinding.image.setBackgroundColor((Integer) animation.getAnimatedValue());\n    }\n});\n```\n\n\n#### ofObject的使用 ####\n\nofObject方法是什么意思呢？我们都知道ofInt和ofFloat都是针对Int值和Float值的变化，但是，我们只能控制一个值的变化，但是当我们需要实现多值变化时，它们就不再满足我们的需求。例如我们需要同时实现位移、透明度变化等动画，这里需要设置两个属性值的变化，所以如果我们只有一个初始值是不行的，因为两个属性的初始值和结束值不一样，那么我们就可以将两个属性值封装到一个对象里面，那么初始值的object和结束值的object就可以包含两个属性不同的初始值和结束值了。\n\n下面是一个对ValueAnimator ofObject (TypeEvaluator evaluator, Object... values)方法具体使用的小Demo，实现图片的放大和渐变过程，先看效果图：\n\n![image](http://7xs0af.com1.z0.glb.clouddn.com/sdfdasdfdas.gif)\n\n首先我们看到ofObject的参数里面有一个TypeEvaluator和一个Object型可变参数，一般传入一个初始值和结束值，首先TypeEvaluator就是一个计算值的工具，API提供有现成的(下面详说)，也可以自己实现(这里为了给大家知道是个什么东西，就自己实现)；然后Obejct型，我们自己写一个类代替Obejct型。\n\n因为我们有两个动画，包括放大和透明度变化，我们定义一个叫ValueObject的类，里面就包含两个属性，代码也非常简单：\n\n\n```\nclass ValueObject {\n    float alphaValue;   //透明度的值\n    float scaleValue;   //伸缩变化的值\n\n    public ValueObject(float alphaValue, float scaleValue) {\n        this.alphaValue = alphaValue;\n        this.scaleValue = scaleValue;\n    }\n}\n```\n\n然后，我们就需要自定义TypeEvaluator了，因为TypeEvaluator是一个接口，我们就写一个名叫MyEvaluator的类，它实现了TypeEvaluator的接口，传入我们的值类型为ValueObject，然后重写evaluate方法（TypeEvaluator接口只有这个方法需要实现）,代码也很简单：\n\n\n```\nclass MyEvaluator implements TypeEvaluator<ValueObject> {\n\n    // 属性动画封装了一个因子fraction，我们设置动画时需要setDuration(xxxx)，例如时间为1000ms，那么当到达100ms时，fraction就为0.1\n    // fraction也就是当前时间占总时间的百分比，startValue和endValue就是我们传入的初始值和结束值\n    @Override\n    public ValueObject evaluate(float fraction, ValueObject startValue, ValueObject endValue) {\n        // 计算某个时刻的alpha值和scale值。类似速度公式Vt = V0 + at\n        float nowAlphaValue = startValue.alphaValue + (endValue.alphaValue - startValue.alphaValue) * fraction;\n        float nowScaleValue = startValue.scaleValue + (endValue.scaleValue - startValue.scaleValue) * fraction;\n        return new ValueObject(nowAlphaValue, nowScaleValue);\n    }\n}\n```\n\n这两个类我们都实现了，那么动画就很简单了：\n\n\n```\npublic void objectAnimation() {\n    // 初始alpha值为1，scale值为1\n    ValueObject startObjectVal = new ValueObject(1f, 1f);\n    // 结束alpha值为0，scale值为2，相当于透明度变为0，尺寸放大到2倍\n    ValueObject endObjectVal = new ValueObject(0f, 2f);\n    MyEvaluator myEvaluator = new MyEvaluator();\n\n    final ValueAnimator animator = ValueAnimator.ofObject(myEvaluator, startObjectVal, endObjectVal);\n    animator.setDuration(3000);\n    animator.start();\n\n    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n        @Override\n        public void onAnimationUpdate(ValueAnimator animation) {\n            mBinding.image.setAlpha(((ValueObject) animation.getAnimatedValue()).alphaValue);\n            mBinding.image.setScaleType(ImageView.ScaleType.CENTER);\n            mBinding.image.setScaleX(((ValueObject) animation.getAnimatedValue()).scaleValue);\n            mBinding.image.setScaleY(((ValueObject) animation.getAnimatedValue()).scaleValue);\n        }\n    });\n}\n```\n\n### 2.2.3常用方法 ###\n\n- **void addUpdateListener(ValueAnimator.AnimatorUpdateListener listener)**：添加值变化监听器。主要监听值变化，实现动画。\n- **void addUpdateListener(AnimatorUpdateListener listener)**：添加动画状态监听器。重写动画开始、结束、取消、重复四个方法，监听不同状态。\n- **void cancel ()**: 取消动画。\n- **void end ()**：让动画到达最后一帧。\n- **void start()**：开始动画。\n- **void pause()**：暂停动画。\n- **void resume()**：继续动画。\n- **void reverse ()**：反向播放动画。\n- **boolean isRunning()**：是否在运行中。\n- **boolean isStarted()**：是否已经开始。\n\n### 2.2.4属性相关的方法 ###\n\n- **void setCurrentFraction(float fraction)**：设置当前时间因子。即时间到达的百分比。\n- **float getAnimatedFraction()**：获取当前时间因子。即时间到达的百分比。\n- **void setCurrentPlayTime (long playTime)**：设置当前的时间，取值为0-duration，单位毫秒。\n- **long getCurrentPlayTime ()**：获取当前的时间，单位毫秒。\n- **ValueAnimator setDuration (long duration)**：设置动画总时长，单位毫秒。\n- **long getDuration ()**：获取动画总时长，单位毫秒。\n- **void setFrameDelay (long frameDelay)**：设置每一帧之间间隔多少毫秒。\n- **long getFrameDelay ()**：获取每一帧之间间隔多少毫秒。\n- **void setInterpolator (TimeInterpolator value)**：设置动画的Interpolator，和View Animation的Interpolator通用。\n- **TimeInterpolator getInterpolator ()**：获取当前使用的插值器。\n- **void setRepeatCount(int value)**：设置重复次数。\n- **int getRepeatCount()**：获取重复次数。\n- **void setRepeatMode(int value)**：设置重复模式。有RESTART和REVERSE两种。\n- **int getRepeatMode()**：获取重复模式。\n- **void setStartDelay(long startDelay)**：设置开始前延迟毫秒数。\n- **long getStartDelay()**：获取开始前延迟毫秒数。\n\n- **void getAnimatedValue()**：获取计算出来的当前属性值。\n- **getAnimatedValue(String propertyName)**：获取计算出来的当前某个属性的值。\n- **void setEvaluator(TypeEvaluator value)**：设置求值器。\n- **void setFloatValues(float... values)**：设置Float型变化值，一般设置初始值和结束值，当然你也可以设置中间值，因为这是一个可变参数，长度可变。\n- **void setIntValues(int... values)**：设置Int型变化值，一般设置初始值和结束值，当然你也可以设置中间值，因为这是一个可变参数，长度可变。\n- **setObjectValues(Object... values)**：设置Object型变化值，一般设置初始值和结束值，当然你也可以设置中间值，因为这是一个可变参数，长度可变。\n\n\n### 2.2.5监听器 ###\n\nValueAnimator有两个监听器，一个是AnimatorListener，一个AnimatorUpdateListener，通过代码我们查看它们的区别。 AnimatorListener主要是用来监听动画不同状态的监听器，从代码中我们可以看到它有四种不同的状态，当我们需要在不同状态中进行不同操作时，我们可以实现这个监听器。AnimatorUpdateListener是监听ValueAnimaitor的值不断变化的过程，通常使用这个监听器更新控件状态，实现动画过程。\n\n\n```\n// AnimatorListener主要是用来监听动画不同状态的监听器\nanimator.addListener(new Animator.AnimatorListener() {\n    @Override\n    public void onAnimationStart(Animator animation) {\n        Log.i(\"TAG\", \"start\");\n    }\n\n    @Override\n    public void onAnimationEnd(Animator animation) {\n        Log.i(\"TAG\", \"end\");\n    }\n\n    @Override\n    public void onAnimationCancel(Animator animation) {\n        Log.i(\"TAG\", \"cancel\");\n    }\n\n    @Override\n    public void onAnimationRepeat(Animator animation) {\n        Log.i(\"TAG\", \"repeat\");\n    }\n});\n```\n\n\n```\n// AnimatorUpdateListener是监听ValueAnimaitor的值不断变化的过程\nanimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation) {\n        Log.i(\"TAG\", \"curVal:\" + animation.getAnimatedValue());\n    }\n});\n\n```\n\n# 三、Interpolator #\n\nInterpolator，译名插值器，在我的意思里就是加速器，即这是一个改变我们动画速率的一个工具，可以实现加速、减速、匀速等这些特效。我们在[Android基础夯实--重温动画（一）之Tween Animation](http://blog.csdn.net/ljcitworld/article/details/64464931)第五部分讲了Android提供给我们使用的插值器，其实属性动画和视图动画是共用一套Interpolator的。在上面我们讲到，在属性动画中，我们可以通过setInterpolator (TimeInterpolator value)来给我们的动画增加一个插值器，传入参数是TimeInterpolator，通过查阅API，我们可以知道，TimeInterpolator是一个接口。我们再来看看它和我们常用的插值器的关系。\n\n我们常用的插值器，如AccelerateDecelerateInterpolator，AccelerateInterpolator， AnticipateInterpolator，AnticipateOvershootInterpolator等，它们的父类是BaseInterpolator。\n\n而BaseInterpolator是实现了Interpolator，而Interpolator则是继承TimeInterpolator接口。所以究其根源，我们常用的插值器和属性动画使用的TimeInterpolator其实是同一个东西。\n\n既然了解了它们是同一个东西，那么我们就需要了解怎么来实现一个自己的Interpolator了，一般我们只要继承BaseInterpolator，并实现它的getInterpolation(float input)方法就行了。\n\n举个例子，Android提供给我们的LinearInterpolator(这是一个匀速插值器)中，它的getInterpolation是这样的：\n\n\n```\npublic float getInterpolation(float input) {\n    return input;\n}\n```\n\n首先我们看一下参数input是什么，input表示当前动画的进度，它的取值范围是0-1，0代表起点，1代表终点，随着动画的播放，input从0到1逐渐变大；而返回值就是指当前的实际进度，听起来有点拗口，我们可以这么想，例如本来当input为0.1的时候，我们返回值如果大于0.1，那么就说明我们从0到0.1这个阶段是一个加速阶段，如果小于0.1，就说明这是一个减速过程。可以看到LinearInterpolator是直接把input返回，可以知道这是一个匀速的过程。\n\n再来看看AccelerateDecelerateInterpolator，这是开始和结束速度慢，中间部分加速。我们来看一下它的getInterpolation函数：\n\n\n```\npublic float getInterpolation(float input) {\n    return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;\n}\n```\n可以看到这就是一个余弦公式，因为0-1这个时间内，刚开始和结束前这两个部分斜率是比较低的，所以速度会比较慢，但是中间部分斜率明显变大，所以中间部分呈现加速状态。\n\n![余弦公式](http://7xrwkh.com1.z0.glb.clouddn.com/%E6%97%A0%E6%A0%87%E9%A2%98.png)\n\n经过这两个例子，我们大概知道，当我们需要实现一个Interpolator时，只需要继承BaseInterpolator，并实现它的getInterpolation(float input)方法就行了，举个例子：实现一个0-0.25秒内到达3/4，0.25-0.75秒内从3/4退回1/4，最后0.25秒内从1/4达到终点，先上效果图让大家比较直观了解：\n\n![Demo](http://7xrwkh.com1.z0.glb.clouddn.com/awww.gif)\n\n所以我们可以很清楚的列出关系式：\n\n![关系式](http://7xrwkh.com1.z0.glb.clouddn.com/YY%E5%9B%BE%E7%89%8720170327174154.jpg)\n\n那么在getInterpolation中，对应根据input列出算法：\n\n![算法](http://7xrwkh.com1.z0.glb.clouddn.com/1490607864%281%29.jpg)\n\n那么代码也自然出来了：\n\n\n```\nclass MyInterpolator extends BaseInterpolator {\n    @Override\n    public float getInterpolation(float input) {\n        if (input <= 0.25) {\n            return 3 * input;\n        } else if (input <= 0.75) {\n            return (1 - input);\n        } else {\n            return 3 * input - 2;\n        }\n    }\n}\n```\n\n# 四、Evaluator #\n\nEvaluator在属性动画中也是起着重要的一环。先看一张图：\n\n![Evaluator](http://7xrwkh.com1.z0.glb.clouddn.com/dd.jpg)\n\n我们可以看到，当Interpolator返回了当前进度滞后，Evaluator就会根据进度来计算出确定的值，以供监听器返回，所以我们就可以知道了，Evaluator其实就是一个根据我们需求而制作的一个计算器。\n\n其实在上面的例子我已经简单地教大家自定义了一个Evaluator，在属性动画中，Android 也为我们提供了很多的Evaluator，例如IntEvaluator，FloatEvaluator等，我们可以先看一下IntEvaluator的底层实现：\n\n\n```\npublic class IntEvaluator implements TypeEvaluator<Integer> {\n\n    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {\n        int startInt = startValue;\n        return (int)(startInt + fraction * (endValue - startInt));\n    }\n}\n```\n\n代码非常的简单，只是重写了一个evaluate方法，在返回值中是一条公式，就是根据开始值和结束值，当前进度，计算结果，并返回，这条公式也是非常简单，这里就不详说了。但是实际开发中，有时候原生的Evaluator不适合我们使用的时候，我们就需要自定义一个Evaluator，正如我上面的例子中用到的，当我们使用了自定义的Object作为初始值和结束值时，我们就需要定义一个自己的Evaluator。下面举一个为了自定义而自定义的Evaluator：\n\n![Evaluator](http://7xrwkh.com1.z0.glb.clouddn.com/dfddf.gif)\n\n由图可知，自定义的Evaluator就是在FloatEvalutor的基础之上加了200个像素，而我自定义的Evaluator也是修改了以下FloatEvaluator的代码：\n\n\n```\nclass MyEvaluator implements TypeEvaluator<Float> {\n\n    @Override\n    public Float evaluate(float fraction, Float startValue, Float endValue) {\n        return startValue + fraction * (endValue - startValue) + 200;\n    }\n}\n```\n\n这是FloatEvaluator的代码：\n\n\n```\npublic class FloatEvaluator implements TypeEvaluator<Number> {\n    public Float evaluate(float fraction, Number startValue, Number endValue) {\n        float startFloat = startValue.floatValue();\n        return startFloat + fraction * (endValue.floatValue() - startFloat);\n    }\n}\n```\n\n所以到这里大家也可以大概了解了怎么自定义Evaluator，非常的简单，实现TypeEvaluator接口，并传入一个类型，也就是初始值和结束值的类型，然后重写evaluate方法，根据当前进度fraction来计算当前的返回值即可。\n\n\n# 五、 总结 #\n\n总体来说，ValueAnimator并不会很难，只要我们掌握了Animator的初始化、初始值、结束值、fraction、Evaluator、监听器的概念，那么我们基本掌握了ValueAnimator的使用，当然，伴随着我们的重复使用、加深理解，当然我们离熟悉掌握ValueAnimator也不远了。当然Animator中除了ValueAnimator以外，还有ObjectAnimator，这也是一个非常重要的概念，下一篇，我给大家带来ObjectAnimator的详解。\n","tags":["动画"],"categories":["学习"]},{"title":"Android基础夯实--重温动画（三）之初识Property Animation","url":"/2017/04/02/Android基础夯实--重温动画（三）之初识Property Animation/","content":"\n*每个人都有一定的理想，这种理想决定着他的努力和判断的方向。就在这个意义上，我从来不把安逸和快乐看作生活目的的本身——这种伦理基础，我叫它猪栏的理想。——爱因斯坦*\n\n# 一、摘要 #\n\nProperty Animation（属性动画）是一个非常强大的框架，它允许你让任何对象都实现动画效果。  因为不管一个对象是否出现屏幕中，你都可以随时去改变它的属性，而属性动画正是通过在某个时间点改变对象的属性实现动画效果的。Property Animation是在Android 3.0（API 11）之后推出的，以其具有高扩展性，解决了一些View Animation所不能解决的问题，所以，对于Android开发者来说，Property Animation是一个非常重要的知识点。\n\n本文主要对ValueAnimator做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。\n\n## 1.1 背景 ##\n\n由于Tween Animation（补间动画）只能实现简单的四种的动画（alpha、scale、rotate、translate），要想实现比较复杂的动画就难以满足需求，而Frame Animation只是改变了View对象绘制的背景，而没有改变View对象本身。所以当我们想使用View Animation实现一些特殊的动画效果时，就比较困难了。例如，当我们想改变一个控件的背景颜色时，视图动画并不能实现；当我们想设置一个按钮在位置转换之后，仍然保持点击事件，视图动画也不能实现。在这个背景之下，属性动画应运而生。\n\n## 1.2 区别 ##  \n\n说了这么多，那么视图动画和属性动画到底有什么区别呢？\n\n首先，在直观上，属性动画是区别于视图动画的：\n\n**(1) 时间不一样：** 视图动画是从API LEVEL 1就引入了；而属性动画是从API LEVEL 11之后才引入。\n\n**(2) 名字不一样：** 视图动画的Tween Animation命名为xxxAnimation、Frame Animation命名为AnimationDrawable；而属性动画，则命名为xxxAnimator。\n\n**(3) 包名不一样：** 视图动画的Tween Animation在包android.view.animation下，而Property Animation在包android.animation中。 \n\n\n\n其次，从根本上，我们可以总结出视图动画和属性动画的两个主要区别：\n  \n(1) **视图动画只能改变View的位置或者视觉效果，并不能改变其属性**。例如：使用Tween Animation对Button实现位移变换后位置改变，但是点击Button最后停留位置时，并不能响应点击事件。怎么理解呢，举个例子：\n\n![视图动画不能改变其属性](http://7xs0af.com1.z0.glb.clouddn.com/jfkdjklfdjl.gif)\n\n由上图可知，我们给TextView设置了点击事件，当我们分别使用Tween Animation和Property Animation移动TextView时，当使用Tween Animation位移TextView后，它的点击事件无效，当使用Property Animation移动TextView后，它的点击事件仍然有效。由此可见，视图动画并不能改变View的属性，而属性动画可以。\n\n(2) **视图动画作用对象只限制为View，而属性动画作用对象不限为View，而是任何对象**。例如：属性动画可以改变颜色值而视图动画做不到。同样举个例子：\n\n![视图动画只作用于View](http://7xs0af.com1.z0.glb.clouddn.com/sdfd.gif)\n\n由上图可以看到，当我们需要对一个对象的颜色值进行改变时，视图动画并不能实现这个效果，上图是通过属性动画来实现的，由此可以推测出，视图动画只能对View起作用，而属性动画作用的不只是View，而是对象。\n\n\n## 1.3 建议 ##\n\n虽然Property Animation的优点要多于View Animation，但是View Animaiton可以让我们花更少的时间和更少的代码去实现，所以如果View Animation已经足以满足我们的日常需要，那么我们就没必要使用Property Animation了，当然，如果我们都涉及到的话，同时使用View Animation和Property Animation可能是更有效的办法。\n\n如果你想了解更权威的解释，可以查看官方文档：[Property Animation](https://developer.android.com/guide/topics/graphics/prop-animation.html#property-vs-view)。\n\n本文主要对Property Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章：\n\n[Android基础夯实--重温动画（一）之Tween Animation](http://blog.csdn.net/ljcitworld/article/details/64464931)\n\n[Android基础夯实--重温动画（二）之Frame Animation](http://blog.csdn.net/ljcitworld/article/details/64919970)\n\n\n# 二、工作原理 #\n\n在讲述具体Property Animation相关API之前，我想先给大家讲一下属性动画是如何工作的。下面通过一个例子，这是[Android开发指南](https://developer.android.com/guide/topics/graphics/prop-animation.html)上面的一个例子，我觉得非常好理解，这里就搬过来了。\n\n首先，我们来看一个例子。如下图描述的是一个对象在它的x方向上进行水平运动的动画（规定右方向为正轴），当然我们可以对应成手机屏幕上的位置。这个动画的时长为40ms，对象在x正方向运动了40个像素，在每个10ms内，这个对象就往x正方向运动10个像素，在第40ms时，这个动画停在了x方向上的40像素，这是一个水平匀速运动的例子。\n\n![图1 匀速水平运动示例](https://developer.android.com/images/animation/animation-linear.png)\n\n\n当然，我们也可以给动画定义一个具有不匀速插值器(Interpolation)，是它运动过程为不匀速。\n如下图也是一个对象的运动过程，但是它并不是匀速运动，而是开始加速，在结束前减速。这个对象仍然是在40秒内运动了40个像素的距离，但是这个过程是不匀速的，它从开始到中间位置进行了加速运动，在中间位置到结束位置则进行了减速运动。\n\n![图2 非匀速水平运动示例](https://developer.android.com/images/animation/animation-nonlinear.png)\n\n从上面两个例子可以看到，当我们想要一个对象实现一定的动画效果时，我们可以通过对应的图，还有相关的数据，和相关数据伴随时间的变化来描述该动画过程，但是我们的属性动画的内部是如何像我们这样来描述自身的变化过程的呢？以ValueAnimator为例，我们来看一下属性动画的重要组成部分，如下图所示。\n\n![图3 属性动画的组成部分](https://developer.android.com/images/animation/valueanimator.png)\n\nValueAnimator是属性动画最基础的一个类（我们暂且不深究它，反正它能帮助我们实现图2的先加速后减速的过程）。首先它在内部封装了非常重要的两个接口，第一个就是TimeInterpolator，另一个是TypeEvaluator。大家在心里必须先有个概念，在所有的属性动画里面，都拥有这两个东西。\n\nTimeInterpolator是什么呢？非常简单，就是我们上面所说的插值器，简单来说就是描述对象加速度的一个东西，再简单一点来说就是描述速度变化的一个东西。\n\nTypeEvaluator又是什么呢？大家可以理解为求值器，它是根据上面的插值器来计算对象属性具体值的这么一个东西。\n\nValueAnimator在执行之前，首先会把时间分为百分数，由0~1，如上图动画过程为40ms，那么在10ms时，时间因子为0.25，在40ms时，时间因子为1。\n\n在计算完时间因子之后，ValueAnimator会调用TimeInterpolator来进行计算插值因子，在图2对应为速度，对应10ms时的速度我们知道会比20ms时的速度会低；而图1中，每一个时刻的速度都一样，所以TimeInterpolator大概是做这么一件事情。\n\n在TimeInterpolator计算完了之后，那么我们的TypeEvaluator就要起作用了，因为上图对应的是对象的位置变化，所以TypeEvaluator为IntEvaluator。这个TypeEvaluator主要是根据TimeInterpolator提供的插值因子(速度)，还有startPropertyValue(开始时间)和endPropertyValue(结束时间)，计算出某个时刻的属性值(位移)，如图2，假如t=10ms时刻，TimeInterpolator给我们返回值为0.15，那么这时在x方向上的位移为0.15 * (40 - 0) = 6。\n\n而这种计算过程在动画执行时间(duration)内是不断重复的，因为ValueAnimator有一个叫做AnimatorUpdateListener的监听器，它会跟踪动画的每一个时刻，所以我们可以在里面进行不断的计算，通过getAnimatedValue()来获取最新值，直到动画结束。\n\n一个属性动画的执行过程大概如上，相信大家已经对属性动画有了基本的了解，那么我们下面根据API来对属性动画进行详细讲解。\n\n# 三、API概况 #\n\n前面我们说到，属性动画机制所有相关的类都位于[android.animation](https://developer.android.com/reference/android/animation/package-summary.html)包之下，所以大家有需要可以到官方文档中进行查阅。下面几个表格是属性动画中常用的类，首先给大家大概介绍。\n\n表格1. Animators\n\nClass | Description\n---|---\nValueAnimator | 针对值变化的Animator。\nObjectAnimator | 针对Object变化的Animator。\nAnimatorSet\t | 运行一组Animator的集合。\n\nAnimator类作为属性动画的基类，它是一个抽象类，它提供了实现动画的基本架构，但是我们不能直接使用它，因为它只是提供了最基本的的实现动画的方法，只有让它的子类继承它并进行相应扩展之后，我们才会使用它实现动画。在属性动画中，Animator包括了ValueAnimator、ObjectAnimator和AnimatorSet三个子类，我们分别来介绍一下这三个类。\n\n表格2.  Evaluators\n\nClass | Description\n---|---\nTypeEvaluator | 求值器接口，所有求值器必须实现该接口。\nIntEvaluator | 计算Int类型的求值器。\nFloatEvaluator | 计算Float类型的求值器。\nArgbEvaluator  | 计算颜色值类型的求值器。\n\nAPI中为我们提供了求值器的接口TypeEvaluator，当然还要它的实现类，例如IntEvaluator、FloatEvaluator、ArgbEvaluator、 IntArrayEvaluator、FloatArrayEvaluator等，它们都是根据fraction因子来计算出对应的属性值，当然我们也可以自定义自己的Evaluator。\n\n表格3. Interpolators\n\nClass | Description\n---|---\nTimeInterpolator | Animator的插值器接口。\n\nTimeInterpolator作为属性动画的插值器接口，我们都知道在View Animation中有很多插值器，例如AccelerateDecelerateInterpolator(前后减速，中间加速)、AccelerateInterpolator（先慢后加速）等插值器，在属性动画中我们同样可以使用这些插值器，这里就不详细列出来了，不了解的同学可以看我之前的文章。当然，我们也可以自定义自己的Interpolator。\n\n# 四、结语 #\n\n由于文章篇幅过长，不利于大家阅读，所以这篇文章首先给大家介绍属性动画这个概念，相信通过例子和文字的介绍，大家也已经对属性动画有所了解，那么接下来，我就会给大家详细讲解属性动画中的每一个知识点，当然，也会分多篇文章进行分析，如果你已经准备好，请继续阅读。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n","tags":["动画"],"categories":["学习"]},{"title":"Android基础夯实--重温动画（二）之Frame Animation","url":"/2017/03/27/Android基础夯实--重温动画（二）之Frame Animation/","content":"*心灵鸡汤：天下事有难易乎，为之，则难者亦易矣；不为，则易者亦难矣。*\n\n# 摘要 #\n\n当你已经掌握了Tween Animation之后，再来看Frame Animation，你就会顿悟，喔，原来Frame Animation简单多了，那么恭喜你，你已经在Animation这条路上走得越来越远了，当你花十来分钟认真看完这篇文章，你就已经走完了动画这条小路的2/3。\n\n# 概述 #\n\n我们都知道，在Android系统中，官方给我们提供了两种类型的动画：**属性动画(Property Animation)** 和 **视图动画(View Animation)**，而视图动画又包含了两种类型：补间动画(Tween animation) 和 帧动画(Frame animation)。\n\n在上一节我们已经对Tween Animation进行了详细讲解，这一片，我会给大家介绍视图动画的另一种 Frame Animation。\n\n在开发中，除了常用的Tween Animation以外，我们还会用到Frame Animation，就是我们所说的帧动画，之所以要实现帧动画是因为它可以实现类似电影的动态效果，因为我们平时所拍的视频也是通过一张张照片插入每一帧，串联起来，从而实现连续播放的视觉效果，而这Tween Animation是无法实现，只能通过Frame Animation来实现。例如我们常见的App动态引导页，很多都是通过Frame Animation来实现的。\n\n![引导页](http://7xs0af.com1.z0.glb.clouddn.com/ezgif.com-resize.gif)\n\n总体来说，Frame Animation实现起来也是比较简单，本文也是主要做一个抛砖引玉，只做基本介绍，更多进阶知识需要大家日后摸索，更权威解释可以看官方文档：[Frame Animation](https://developer.android.com/guide/topics/resources/animation-resource.html#Frame)。以下先通过Demo给大家更直观地展示Frame Animation。\n\n本文主要对View Animation的Frame Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。\n\n# Demo #\n\n这个Demo主要是使用Frame Animation来实现ImageView播放gif图效果。\n\n## 效果图 ##\n\n![效果图](http://7xs0af.com1.z0.glb.clouddn.com/sfdf.gif)\n\n## 代码实现 ##\n\n1. 首先在res/drawable/目录下，增添一个frame.xml文件，里面主要写每一帧播放哪一张照片。最外层标签必须是animation-list，子标签item对应每一帧，每一个item里面的drawable属性对应图片位置、duration对应一帧的时长。\n\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:oneshot=\"false\">\n    <item\n        android:drawable=\"@drawable/g1\"\n        android:duration=\"200\" />\n    <item\n        android:drawable=\"@drawable/g2\"\n        android:duration=\"200\" />\n    <item\n        android:drawable=\"@drawable/g3\"\n        android:duration=\"200\" />\n    <item\n        android:drawable=\"@drawable/g4\"\n        android:duration=\"200\" />\n    <item\n        android:drawable=\"@drawable/g5\"\n        android:duration=\"200\" />\n    <item\n        android:drawable=\"@drawable/g6\"\n        android:duration=\"200\" />\n</animation-list>\n\n```\n\n2. 在Activity中，实现如下代码：\n\t\n\t//将控件背景设置为我们的AnimationDrawable资源文件\n\timage.setBackgroundResource(R.drawable.frame);\n\tmBinding.play.setOnClickListener(new View.OnClickListener() {\n\t    @Override\n\t    public void onClick(View v) {\n\t        //拿到要编译成AnimationDrawable的背景\n\t        AnimationDrawable imageAnimation = (AnimationDrawable)image.getBackground();\n\t        //开始动画\n\t        imageAnimation.start();\n\t    }\n\t});\n\n# Frame Animation #\n\n在Android的官方文档中，Google对Frame Animation的讲解只是用了比较小的篇幅，可能是因为过于简单，当然，大家通过我上面所说的例子也可以看得出Frame Animation的使用也是非常的简单，下面主要介绍Frame Animation的要点。\n\n## 文件位置 ##\n\n在资源文件夹下：res/drawable/filename.xml\n\n## 编译 ##\n\n在上面的例子我们可以了解到，在Activity中，我们是通过image.getBackground()获取到的对象转为了AnimationDrawable，这是因为在我们的xml文件被编译器编译之后就变成了 [AnimationDrawable](https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html)类。\n\n## 语法 ##\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:oneshot=[\"true\" | \"false\"] >\n\t    <item\n\t        android:drawable=\"@[package:]drawable/drawable_resource_name\"\n\t        android:duration=\"integer\" />\n\t</animation-list>\n\n## 标签 ##\n\n** < animation-list > ** ：外层必须要的标签，里面包含一个以上的<item>标签\n\n- 属性：\n    1. android:oneshot：true则只运行一次，false则重复动画。\n\n** < item > ** ：每一帧的动画，必须是<animation-list>的子标签。\n\n- 属性：\n    1. android:drawable：对应资源文件。\n    2. android:duration：每一帧时长。\n\n## AnimationDrawable ##\n\nAnimationDrawable就是对应于我们自身定义的xml文件，在Java代码中将xml对象转为了AnimationDrawable之后，我们就可以通过它来获取xml文件里面的属性。\n\n### 父类 ###\n\nAnimationDrawable继承于Object -> Drawable -> DrawableContainer。\n\n### 接口 ###\n\n实现了Runnable, Animatable接口。    \n\n### XML文件中的变量 ###\n\n- **android:drawable：** 用于该帧的图片。\n- **android:duration：** 每一帧的时长。\n- **android:oneshot：** true则只运行一次，false则重复动画。\n- **android:variablePadding：** 如果true，允许drawable文件的当前状态改变。\n- **android:visible：** 是否可见。\n\n\n### 方法 ###\n\n- **void addFrame (Drawable frame, int duration)：** 添加一帧动画到动画里面。\n- **int getDuration (int i)：** 获取第i帧的时长。\n- **Drawable getFrame (int index)：** 获取第i帧的Drawbale。\n- **int getNumberOfFrames ()：** 获取共有多少帧。\n- **void inflate (Resources r, XmlPullParser parser, AttributeSet attrs, Resources.Theme theme)：** 从XML资源里面加载一个Drawable文件。\n- **boolean isOneShot ()：** 判断是否单次播放。\n- **boolean isRunning ()：** 判断动画是否还在运行。\n- **Drawable mutate ()：** 一个drawable如果使用了mutate()方法，那么对这个drawable属性（包括设置drawable的透明度）修改将不会共享。\n- **void setOneShot (boolean oneShot)：** 设置动画播放一次或者循环。\n- **boolean setVisible (boolean visible, boolean restart)：** 设置该AnimationDrawable是否可见。\n- **void start ()：** 播放。\n- **void stop ()：** 停止。\n- **void unscheduleSelf (Runnable what)：** 让动画重新回到-1帧。\n\n# 总结 #\n\nFrame Animation总体来说比较简单，通过XML的划分帧，在Java代码中获取到编译的AnimationDrawable，然后进行播放，难点不多，却是很多引导页的常用实现方法。\n\n\n\n\n\n","tags":["动画"],"categories":["学习"]},{"title":"Android基础夯实--重温动画（一）之Tween Animation","url":"/2017/03/21/Android基础夯实--重温动画（一）之Tween Animation/","content":"\n*心灵鸡汤：真正成功的人生，不在于成就的大小，而在于你是否努力地去实现自我，喊出自己的声音，走出属于自己的道路。*\n\n\n# 摘要 #\n\n不积跬步，无以至千里；不积小流，无以成江海。学习任何东西我们都离不开扎实的基础知识，这次我们重温Android中让我们又爱又恨的动画。即便没有很好的算法思想，但是掌握了Animation的基础，我们同样可以通过动画给我们的App增色不少。\n\n# 概述 #\n\n在我们日常开发中，我们都希望我们的App拥有及其炫酷的动画效果，除了一些SDK提供给我们拥有炫酷动画效果的控件外，都需要我们自己来实现。在Android系统中，官方给我们提供了两种类型的动画：**属性动画(Property Animation)** 和 **视图动画(View Animation)**，而视图动画又包含了两种类型：补间动画(Tween animation) 和 帧动画(Frame animation)。\n\n1.  Property Animation(属性动画)：通过改变对象的属性来实现动画效果。\n\n2.  View Animation(视图动画)：包括了以下两种动画类型。\n\n    - *Tween Animation(补间动画)*：通过对视图进行一系列的动作变化实现动画效果。\n    \n    - *Frame Animation(帧动画)*：通过一组图片有序播放实现动画视觉效果。\n    \n![Android官方文档 Animation的分类](http://7xs0af.com1.z0.glb.clouddn.com/YY%E5%9B%BE%E7%89%8720170317181609.jpg)\n\n\n为此，由于篇幅过长，笔主通过三篇博文来重温Animation的相关基础知识，内容主要作为抛砖引玉，围绕这三种动画作简单的介绍，因为所有的动画都是以这几种动画为基础，配合其他的技术，例如自定义View、还有一些曲线函数等，做出很多炫酷的效果。但是，炫酷动画万万千，我们做的每一个动画需求都是源自设计师的灵感，所以这篇文章就不对动画的高阶讲解，相反，是作为抛砖引玉，所以如果你已经非常熟悉动画相关，可以跳过，但是如果你对动画还是不了解，不妨继续看下去。\n\n当然，更权威的解释请查看官方文档：[Animation Resources](https://developer.android.com/guide/topics/resources/animation-resource.html#Property)\n\n本文首先对View Animation的Tween Animation做介绍，如果大家有兴趣，可以继续阅读本动画系列其他相关文章，作者也在不断更新完善相关内容，希望大家可以指出有误之处。\n\nTween Animation，翻译为补间动画，是View Animation两种中的一种，是Android开发中使用最普遍的动画，当然也是使用率最高的一种动画，因为它能够基本满足我们的动画需要，主要是通过对控件实现透明度(alpha)、尺寸(scale)、位置(translate)、旋转rotate)进行改变，通过集合(set)的方式，实现连续的动画效果。\n\n\n## 一、动画资源文件的位置 ##\n\n![动画资源文件的位置](http://7xs0af.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720170317152414.png)\n\n## 二、类型 ##\n\nTween Animation是View Animation其中之一，Tween Animation可以实现对控件实现以下四种变换:\n\n1. alpha：透明度渐变动画效果\n2. scale：尺寸变化动画效果\n3. translate：位置移动动画效果\n4. rotate：转移旋转动画效果\n\n## 三、使用方式 ##\n\n1. 在XML文件中定义一系列的动画标签，所有便签在set便签里面构成集合\n2. Java文件中代码实现\n\n之所以可以这样，是因为四个便签都有对应的Java类：AlphaAnimation, RotateAnimation, ScaleAnimation, TranslateAnimation。\n\n所在包：android.view.animation.*\n\n都继承于父类：[android.view.animation.Animation](https://developer.android.com/reference/android/view/animation/Animation.html)\n\n## 四、Animation类 ##\n\nTween Animation的所有效果都是继承于Animation类，Animation类作为一个抽象类，提供了动画基本属性的实现，需要由具体的子类来具体实现。\n\n### 直接子类 ###\n\n- AnimationSet：代表着一组可以一起播放的动画。\n- AlphaAnimation：控制一个对象透明度的动画。\n- RotateAnimation：控制一个对象旋转的动画。\n- ScaleAnimation：控制一个对象尺寸的动画。\n- TranslateAnimation：控制一个对象位置的动画。\n\n### 监听器 ###\n\n- Animation.AnimationListener：动画监听器。主要包括监听动画执行中、执行结束、循环执行三个过程。\n\n\n```\nmAnimation.setAnimationListener(new Animation.AnimationListener() {\n    @Override\n    public void onAnimationStart(Animation animation) {\n            // 动画执行时\n        }\n\n        @Override\n        public void onAnimationEnd(Animation animation) {\n            // 动画结束时\n        }\n\n        @Override\n        public void onAnimationRepeat(Animation animation) {\n            // 动画循环时\n        }\n    });\n```\n\n\n### 属性及其对应方法(所有子类都拥有) ###\n\n- **android:detachWallpaper：** 是否在壁纸上运行\n```\nJava方法：setDetachWallpaper(boolean detachWallpaper)\n```\n- **android:duration：**  动画时长，单位毫秒。\n```\nJava方法：setDuration(long)\n```\n- **android:fillAfter：** 设置为true，控件动画结束时将保持动画最后一帧（xml文件中，需要设置在set便签才生效）。\n```\nJava方法：setFillAfter(boolean)\n```\n- **android:fillBefore：** 设置为true，控件动画结束时将保持动画开始第一帧（感觉很坑爹，设置true和false还有删除这个属性，效果都一样）。\n```\nJava方法：setFillBefore(boolean)\n```\n- **android:fillEnabled：** 效果和fillBefore一样（同样坑爹，经测试这个属性可有可无，求打脸。\n```\nJava方法：setFillEnabled(boolean)\n```\n- **android:interpolator：** 插值器。设置动画速率的变化(譬如加速、减速、匀速等)，后面详说。\n```\nJava方法：setInterpolator(Interpolator)\n```\n- **android:repeatCount：** 动画重复次数。\n```\nJava方法：setRepeatCount(int)\n```\n- **android:repeatMode：** 重复模式，有reverse(倒序)和restart(重复)两种，必须配合repeatCount一起使用。\n```\nJava方法：setRepeatMode(int)\n```\n- **android:startOffset：** 延迟一定毫秒之后才开始动画。\n```\nJava方法：setStartOffset(long)\n```\n- **android:zAdjustment：**  表示被设置动画的内容在动画运行时在Z轴上的位置，有以下三个值\n    - normal 默认值，保持内容在Z轴上的位置不变\n    - top 保持在Z周最上层\n    - bottom 保持在Z轴最下层\n```\nJava方法：setZAdjustment(int)\n```\n\n## 五、Interpolator ##\n\nInterpolator，又名插值器，主要是实现动画的速率变化。Interpolator作为一个接口，然后抽象类BaseInterpolator实现Interpolator接口，在BaseInterpolator的子类就是一系列Android提供的插值器。\n\n用法：\n\n1. 在XML的标签下设置:android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n2. 在JAVA代码中使用：animation.setInterpolator(new AccelerateDecelerateInterpolator());\n\n![Interpolator](http://7xs0af.com1.z0.glb.clouddn.com/YY%E5%9B%BE%E7%89%8720170321171708.jpg)\n\n以下为Andorid所提供的所有插值器：\n\n- 1、AccelerateDecelerateInterpolator：开始和结束速度慢，中间部分加速。\n- 2、AccelerateInterpolator：开始缓慢，然后加速。\n- 3、AnticipateInterpolator: 开始后退，然后前进。\n- 4、AnticipateOvershootInterpolator: 开始后退，然后前进，直到超出目标值，再后退至目标值。\n- 5、BounceInterpolator：在结束时弹跳。\n- 6、CycleInterpolator：在指定数量的周期内重复动画，速度变化遵循正弦规律。\n- 7、DecelerateInterpolator：开始加速，结束缓慢。\n- 8、LinearInterpolator：匀速。\n- 9、OvershootInterpolator：前进，直到超出目标值，再后退至目标值。\n- 10、PathInterpolator：根据路径变化改变速率。\n\n关于以上所有插值器的Demo：\n\n![1-3](http://7xs0af.com1.z0.glb.clouddn.com/mg1.gif)\n\n![4-7](http://7xs0af.com1.z0.glb.clouddn.com/mg2.gif)\n\n![8-10](http://7xs0af.com1.z0.glb.clouddn.com/mg3.gif)\n\n## 六、AnimationSet ##\n\nAnimationSet是动画中非常重要的概念，继承于Animation类，它将很多独立的动画包裹到一个集合内，形成一个共同作用的动画效果。例如，我们会在res/anim/目录下的xml文件里面这样实现一个包含多种效果的动画(透明度、尺寸、位置、旋转)：\n\n\n```\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fillAfter=\"true\"\n    android:shareInterpolator=\"false\">\n    <scale\n        android:duration=\"1500\"\n        android:fromXScale=\"1.0\"\n        android:fromYScale=\"1.0\"\n        android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"1.4\"\n        android:toYScale=\"0.6\" />\n    <set\n        android:duration=\"1000\"\n        android:interpolator=\"@android:anim/accelerate_interpolator\"\n        android:startOffset=\"1500\">\n        <scale\n            android:fromXScale=\"1.4\"\n            android:fromYScale=\"0.6\"\n            android:pivotX=\"50%\"\n            android:pivotY=\"50%\"\n            android:toXScale=\"0.0\"\n            android:toYScale=\"0.0\" />\n        <rotate\n            android:fromDegrees=\"0\"\n            android:pivotX=\"50%\"\n            android:pivotY=\"50%\"\n            android:toDegrees=\"-45\" />\n    </set>\n</set>\n```\n\n效果如下：\n\n![AnimationSet](http://7xrxlv.com1.z0.glb.clouddn.com/ezgif.com-video-to-gif%20%282%29.gif)\n\n当然，你可以使用Java代码来实现，逻辑和在XML中实现的是一样的，如下：\n\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private ActivityMainBinding mainBinding;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        mainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main);\n\n        //参数为false，不共享Interpolator\n        AnimationSet set = new AnimationSet(false);\n        set.setFillAfter(true);\n\n        // Scale动画\n        ScaleAnimation scaleAnimation = new ScaleAnimation(1.0f, 1.4f, 1.0f, 0.6f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\n        scaleAnimation.setInterpolator(new AccelerateDecelerateInterpolator());\n        scaleAnimation.setDuration(1500);\n        set.addAnimation(scaleAnimation);\n\n        // mSet集合\n        AnimationSet mSet = new AnimationSet(true);\n        mSet.setInterpolator(new AccelerateInterpolator());\n        mSet.setDuration(1000);\n        mSet.setStartOffset(1500);\n\n        // Scale动画\n        ScaleAnimation mScaleAnimation = new ScaleAnimation(1.4f, 0.0f, 0.6f, 0.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\n        mSet.addAnimation(mScaleAnimation);\n        // Rotate动画\n        RotateAnimation mRotateAnimation = new RotateAnimation(0.0f, -45.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\n        mSet.addAnimation(mRotateAnimation);\n\n        set.addAnimation(mSet);\n\n        mainBinding.image.startAnimation(set);\n    }\n}\n```\n\n### 构造函数 ###\n\n- AnimationSet(Context context, AttributeSet attrs) ：当需要加载AttributeSet时使用的构造函数。\n- AnimationSet(boolean shareInterpolator)：当从代码实现AnimationSet时，传入是否子动画是否共享插值器参数。\n\n### 主要属性及其方法(父类以外的) ###\n\n#### Java方法 ####\n- **void addAnimation (Animation a)：** 把一个子动画加到Animation Set中去。\n- **long computeDurationHint ()：** 获取最长时间的子动画的时间，单位毫秒。\n- **List<Animation> getAnimations ()：** 获取所有子动画对象的集合。\n- **long getStartTime ()**：获取动画什么时候应该播放，如果方法返回常量 START_ON_FIRST_FRAME (-1)，表明动画未播放。\n- **boolean getTransformation (long currentTime, \n                Transformation t)：** 获取帧动画执行到目前时的变换信息，存到Transformation中，主要用作调试用。\n    例如我们需要当前Scale动画的变换信息：\n    \n    ```\n    Transformation tf = new Transformation();\n    if (scaleAnimation!=null){\n        scaleAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), tf);\n        System.out.println(\"Matrix:\" + tf.getMatrix());\n        System.out.println(\"Alpha:\" + tf.getAlpha());\n        System.out.println(\"TransformationType:\" + tf.getTransformationType());\n    }\n    ```\n- **void initialize (int width, \n                int height, \n                int parentWidth, \n                int parentHeight)：** 初始化动画的宽高和父动画的宽高。\n- **void reset ()：** 重置动画的初始状态。\n- **void restrictDuration (long durationMillis)：** 限制动画不能超过durationMillis个毫秒。\n- **boolean willChangeBounds ()：** 动画是否会改变view的尺寸边界。true为会。\n- **boolean willChangeTransformationMatrix ()：** 动画是否会改变view的矩阵。 \n\n\n## 七、AlphaAnimation ##\n\nAlphaAnimation是继承于Animation的一个动画类型，它通过控制控件的透明度变化来实现动画效果，如我们常见的淡入淡出效果就是通过AlphaAnimaiton实现。\n\n不多说，我们来通过例子看一下AlphaAnimation的实现消失动画效果：\n\n![AlphaAnimation](http://7xs0af.com1.z0.glb.clouddn.com/ezgif.com-video-to-gif%20%283%29.gif)\n\n还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。\n\n- **写法一**\n\n在res/anim目录下定义alpha.xml文件，在文件内写：\n\n\n```\n<alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:duration=\"2500\"\n    android:fromAlpha=\"1.0\"\n    android:toAlpha=\"0.0\" />\n\n```\n在Activity中加载xml文件，并绑定控件播放动画：\n\n\n```\nAlphaAnimation animation = (AlphaAnimation) AnimationUtils.loadAnimation(getApplicationContext(), R.anim.alpha);\nimage.startAnimation(animation);\n```\n\n- **写法二**\n\n直接在Java代码中实现：\n\n```\nAlphaAnimation animation = new AlphaAnimation(1.0f, 0.0f);\nanimation.setDuration(2500);\nmBinding.image.startAnimation(animation);\n```\n### 构造函数 ###\n\n- AlphaAnimation(Context context, AttributeSet attrs)：当需要加载AttributeSet时使用的构造函数。\n- AlphaAnimation(float fromAlpha, float toAlpha)：构造函数传入fromAlpha(开始时透明度)， toAlpha(结束时透明度)\n\n\n### 主要属性及其对应方法(父类以外的) ###\n\n#### XML属性 ####\n- **android:fromAlpha：**  动画开始前控件的透明度，取值0.0-1.0，从透明到不透明。\n- **android:toAlpha：** 动画结束时控件的透明度，取值0.0-1.0，从透明到不透明。\n\n#### Java方法 ####\n- **boolean willChangeBounds ()：** 动画是否会改变view的尺寸边界。true为会。\n- **boolean willChangeTransformationMatrix ()：** 动画是否会改变view的矩阵。\n- **void applyTransformation (float interpolatedTime, Transformation t)：** AlphaAnimation的具体实现，只能在AlphaAnimation的子类中重写来实现自己需要的动画效果。\n\n\n## 八、ScaleAnimation ##\nScaleAnimation是继承于Animation的一个动画类型，它通过控制控件的尺寸大小来实现动画效果，如我们常见的放大，缩小效果就是通过ScaleAnimation实现。\n\n同样，先示范：\n\n![ScaleAnimation](http://7xs0af.com1.z0.glb.clouddn.com/scale.gif)\n\n还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。\n\n- **写法一**\n\n在res/anim目录下定义scale.xml文件，在文件内写：\n\n\n```\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fillAfter=\"true\">\n    <scale\n        android:duration=\"1500\"\n        android:fromXScale=\"1.0\"\n        android:fromYScale=\"1.0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toXScale=\"2.0\"\n        android:toYScale=\"2.0\" />\n\n    <scale\n        android:duration=\"1500\"\n        android:fromXScale=\"1.0\"\n        android:fromYScale=\"1.0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:startOffset=\"1500\"\n        android:toXScale=\"0.0\"\n        android:toYScale=\"0.0\" />\n</set>\n```\n在Activity中加载xml文件，并绑定控件播放动画：\n\n\n```\nAnimation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.scale);\nimage.startAnimation(animation);\n```\n\n- **写法二**\n\n在Java代码中实现：\n\n\n```\nAnimationSet set = new AnimationSet(false);\nset.setFillAfter(true);\n\n// 构造函数 fromX, toX, fromY, toY, pivotXType, pivotXValue, pivotYType, pivotYValue\n// pivotXType和pivotYType都有三种取值：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, Animation.RELATIVE_TO_PARENT\nScaleAnimation sa1 = new ScaleAnimation(1.0f, 2.0f, 1.0f, 2.0f, Animation.RELATIVE_TO_SELF,0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\nsa1.setDuration(1500);\n\nScaleAnimation sa2 = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f, Animation.RELATIVE_TO_SELF,0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\nsa2.setDuration(1500);\nsa2.setStartOffset(1500);\n\nset.addAnimation(sa1);\nset.addAnimation(sa2);\n\nmBinding.image.startAnimation(set);\n```\n\n### 构造函数 ###\n\n- **ScaleAnimation(Context context, AttributeSet attrs)：** 当需要加载AttributeSet时使用的构造函数。\n- **ScaleAnimation(float fromX, float toX, float fromY, float toY)：** X方向放大（缩小）前的相对比例，X方向放大（缩小）后的相对比例，Y方向放大（缩小）前的相对比例，Y方向放大（缩小）后的相对比例。\n- **ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)：** pivotX和pivotY是缩放动画围绕的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。\n- **ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)：** 当我们需要输入pivotXValue和pivotYValue为百分数或者百分数加p类型的时候，我们用第三个构造函数显示是不行的，这时候需要传入pivotXType和pivotYType，它们有三种取值：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, Animation.RELATIVE_TO_PARENT。\n\n\n### 主要属性及其方法(父类以外的) ###\n\n#### XML属性 ####\n- **android:fromXScale：**  动画开始前的X方向上的尺寸。\n- **android:fromYScale：**  动画开始前的Y方向上的尺寸。\n- **android:toXScale：**  动画结束时的X方向上的尺寸。\n- **android:toYScale：**  动画结束时的Y方向上的尺寸。\n- **android:pivotX：**  缩放动画围绕X方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。\n- **android:pivotY：**  缩放动画围绕Y方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。\n\n#### Java方法 ####\n- **void initialize (int width, int height, int parentWidth, int parentHeight)：** 初始化动画的宽高和父动画的宽高。\n\n## 九、RotateAnimation ##\nRotateAnimation是继承于Animation的一个动画类型，它通过控制控件旋转来实现动画效果，如我们常见的转动效果就是通过RotateAnimation实现。\n\n先看一个小demo：\n\n![RotateAnimation](http://7xs0af.com1.z0.glb.clouddn.com/rotate.gif)\n\n还是有两种写法，一种在XML里定义动画的样式，一种在Java代码里实现动画的样式。\n\n- **写法一**\n\n在res/anim目录下定义rotate.xml文件，在文件内写：\n\n\n```\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fillAfter=\"true\">\n\n    <rotate\n        android:duration=\"1000\"\n        android:fromDegrees=\"0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:toDegrees=\"360\" />\n\n    <rotate\n        android:duration=\"1500\"\n        android:fromDegrees=\"0\"\n        android:pivotX=\"50%\"\n        android:pivotY=\"50%\"\n        android:startOffset=\"2000\"\n        android:toDegrees=\"-1800\" />\n</set>\n```\n在Activity中加载xml文件，并绑定控件播放动画：\n\n\n```\nAnimation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.rotate);\nimage.startAnimation(animation);\n```\n\n- **写法二**\n\n在Java代码中实现：\n\n\n```\nAnimationSet set = new AnimationSet(false);\nset.setFillAfter(true);\n\nRotateAnimation ra1 = new RotateAnimation(0f, 360f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\nra1.setDuration(1000);\n\nRotateAnimation ra2 = new RotateAnimation(0f, -1800f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);\nra2.setDuration(1500);\nra2.setStartOffset(1000);\n\nset.addAnimation(ra1);\nset.addAnimation(ra2);\n\nmBinding.image.startAnimation(set);\n```\n\n### 构造函数 ###\n\n- **RotateAnimation(Context context, AttributeSet attrs)：** 当需要加载AttributeSet时使用的构造函数。\n- **RotateAnimation(float fromDegrees, float toDegrees)：**\n从fromDegress角度转到toDegress角度(正数为顺时针，负数为逆时针)。\n- **RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)：**\n加上旋转中心点，X方向中心点pivotX和Y方向中心点，取值仍为上面所介绍的三种。\n- **RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)：** 加上中心点的取值类型。\n\n### 主要属性及其方法(父类以外的) ###\n\n#### XML属性 ####\n- **android:fromDegrees：**  动画开始前的角度。\n- **android:toDegrees：**  动画结束时的角度。\n- **android:pivotX：**  缩放动画围绕X方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。\n- **android:pivotY：**  缩放动画围绕Y方向的中心点，当为数值时，表明是屏幕上的绝对坐标值，当为百分数（如50%）时，为相对自己本身控件的比例值，当为百分数加p（如50%p）时，为相对父布局的比例值。\n\n\n#### Java方法 ####\n- **void initialize (int width, int height, int parentWidth, int parentHeight)：** 初始化动画的宽高和父动画的宽高。\n- **void applyTransformation (float interpolatedTime, Transformation t)：** RotateAnimation的具体实现，只能在RotateAnimation的子类中重写来实现自己需要的动画效果。\n\n### 十、TranslateAnimation ###\nTranslateAnimation是继承于Animation的一个动画类型，它通过控制控件位置变化来实现动画效果，如我们常见的位移效果就是通过TranslateAnimation实现。\n\nTranslationAnimation相关的小Demo，围绕四周转动：\n\n![TranslateAnimation](http://7xs0af.com1.z0.glb.clouddn.com/translate.gif)\n\n只展示一种写法，Java代码实现方式同上：\n\n\n在res/anim目录下定义translate.xml文件，在文件内写：\n\n\n```\n<set xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:fillAfter=\"true\">\n\n    <translate\n        android:duration=\"1000\"\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:toXDelta=\"92%p\"\n        android:toYDelta=\"0\" />\n\n    <translate\n        android:duration=\"1000\"\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:startOffset=\"1000\"\n        android:toXDelta=\"0\"\n        android:toYDelta=\"94%p\" />\n    <translate\n        android:duration=\"1000\"\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:startOffset=\"2000\"\n        android:toXDelta=\"-92%p\"\n        android:toYDelta=\"0\" />\n\n    <translate\n        android:duration=\"1000\"\n        android:fromXDelta=\"0\"\n        android:fromYDelta=\"0\"\n        android:startOffset=\"3000\"\n        android:toXDelta=\"0\"\n        android:toYDelta=\"-94%p\" />\n</set>\n\n```\n在Activity中加载xml文件，并绑定控件播放动画：\n\n\n```\nAnimation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.translate);\nmBinding.image.startAnimation(animation);\n```\n\n### 构造函数 ###\n\n- **TranslateAnimation(Context context, AttributeSet attrs)：** 当需要加载AttributeSet时使用的构造函数。\n- **TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)：** fromXDelta（动画开始时的X方向上的位置），toXDelta（动画结束始时的X方向上的位置），fromYDelta（动画开始时的Y方向上的位置），toYDelta（动画结束始时的Y方向上的位置）\n- **TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue)：** 加上类型参数。\n \n### 主要属性及其方法(父类以外的) ###\n\n#### Java方法 ####\n- **void initialize (int width, int height, int parentWidth, int parentHeight)：** 初始化动画的宽高和父动画的宽高。\n- **void applyTransformation (float interpolatedTime, Transformation t)：** TranslateAnimation的具体实现，只能在TranslateAnimation的子类中重写来实现自己需要的动画效果。\n\n# 总结 #\n\n对于很多比较少接触动画的同学，可能都会比较反感，因为觉得动画篇的东西又多又难学，其实不然，就像我们这篇所介绍的Tween Animation，虽然有很多种动画类型，但是几种都是基于父类Animation类，然后在它的基础上进行了稍微扩展，所以当我们认真静下来去看的时候，我们会发现，其实也不过如此。Animation在实际开发中非常常见，尤其本篇所说的最基本的Tween Animation。在Android已经达到了如此成熟的今天，市场上的应用很大一部分依靠炫酷的动画效果来吸引用户，所以掌握动画会帮助你在日后开发中有很大的帮助，不说其他，早点下班是必须的。","tags":["动画"],"categories":["学习"]}]